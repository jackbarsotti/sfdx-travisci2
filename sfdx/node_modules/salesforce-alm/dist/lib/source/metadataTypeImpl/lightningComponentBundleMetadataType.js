"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const glob = require('glob');
const srcDevUtil = require("../../core/srcDevUtil");
const bundleMetadataType_1 = require("./bundleMetadataType");
const PathUtil = require("../sourcePathUtil");
const bundlePathHelper_1 = require("../bundlePathHelper");
class LightningComponentBundleMetadataType extends bundleMetadataType_1.BundleMetadataType {
    constructor(typeDefObj) {
        super(typeDefObj);
    }
    getMdapiFormattedContentFileName(originContentPath, aggregateFullName) {
        // LWC bundles can have nested sub-directories.
        // In order to maintain the bundle structure in the mdapi formatted directory,
        // return the path from the bundle directory to the file
        const pathArray = path.dirname(originContentPath).split(path.sep);
        const dirIndex = pathArray.lastIndexOf(aggregateFullName);
        const pathToBundle = pathArray.slice(0, dirIndex + 1).join(path.sep);
        return path.relative(pathToBundle, originContentPath);
    }
    // Given the LWC meta file path and the retrieved content file path within
    // the temporary directory, return the path to the associated file within
    // the project directory.
    getWorkspaceContentFilePath(metadataFilePath, retrievedContentFilePath) {
        const bundlePath = path.dirname(metadataFilePath);
        const bundleName = bundlePathHelper_1.BundlePathHelper.scanFilePathForAggregateFullName(retrievedContentFilePath, this.typeDefObj.defaultDirectory);
        const fileName = this.getMdapiFormattedContentFileName(retrievedContentFilePath, bundleName);
        return path.join(bundlePath, fileName);
    }
    // This returns the full path to the meta file for the LWC.
    // E.g., unpackaged/lwc/helloworld/helloworld.js-meta.xml
    getRetrievedMetadataPath(fileProperty, retrieveRoot, bundleFileProperties) {
        // There may be an existing, easier way to do this but I don't see
        // anything in BundlePathHelper.  This takes an LWC file path and
        // extracts the bundle path to build the path to the LWC meta file.
        const bundleName = bundlePathHelper_1.BundlePathHelper.scanFilePathForAggregateFullName(fileProperty.fileName, this.typeDefObj.defaultDirectory);
        const pathArray = path.dirname(fileProperty.fileName).split(path.sep);
        const bundleIndex = pathArray.lastIndexOf(bundleName);
        const bundlePath = pathArray.slice(0, bundleIndex + 1).join(path.sep);
        const fileName = bundlePathHelper_1.BundlePathHelper.getMetadataFileNameFromBundleFileProperties(fileProperty.fullName, bundleFileProperties);
        const retrievedMetadataPath = path.join(retrieveRoot, bundlePath, fileName);
        if (srcDevUtil.pathExistsSync(retrievedMetadataPath)) {
            return retrievedMetadataPath;
        }
        return null;
    }
    getCorrespondingLWCDefinitionFileProperty(retrieveRoot, filePropertyFileName, lwcMetadataName, metadataRegistry) {
        const bundleDirPath = path.join(retrieveRoot, path.dirname(filePropertyFileName));
        const bundlePaths = glob.sync(path.join(bundleDirPath, '*'));
        const bundleDefinitionPath = bundlePaths.find(bundlePath => this.isDefinitionFile(bundlePath));
        const lwcDefinitionFileProperty = {
            type: lwcMetadataName,
            fileName: path.relative(retrieveRoot, bundleDefinitionPath),
            fullName: path.basename(bundleDefinitionPath, path.extname(bundleDefinitionPath))
        };
        return lwcDefinitionFileProperty;
    }
    // For LWC, the meta file is always in the bundle dir with `-meta.xml` appended to the
    // main JS file.
    // E.g., lwc/helloworld/helloworld.js-meta.xml
    isDefinitionFile(filePath) {
        const fixedFilePath = PathUtil.replaceForwardSlashes(filePath);
        const fileExt = (path.extname(fixedFilePath) || '').toLowerCase();
        if (fileExt === '.js') {
            const pathArray = path.dirname(fixedFilePath).split(path.sep);
            const aggFullName = bundlePathHelper_1.BundlePathHelper.scanFilePathForAggregateFullName(fixedFilePath, this.typeDefObj.defaultDirectory);
            const fileName = path.parse(fixedFilePath).name;
            return aggFullName === fileName && aggFullName === pathArray[pathArray.length - 1];
        }
        return false;
    }
    shouldDeleteWorkspaceAggregate(metadataType) {
        // Handle deletes of LightningComponentBundles at the subcomponent level because
        // SourceMembers are created for each subcomponent
        return false;
    }
    trackRemoteChangeForSourceMemberName(sourceMemberName) {
        // Whenever a resource of an LightningComponentBundle is modified in the scratch org, a SourceMember is created
        // at the bundle level and another is created for the changed resource. Ignore the SourceMember created
        // for the bundle and track specific bundle resource changes only.
        return sourceMemberName.split(path.sep).length > 1;
    }
    onlyDisplayOneConflictPerAggregate() {
        //we only want to report one conflict entry per bundle
        return true;
    }
    getDisplayPathForLocalConflict(workspaceFilePath) {
        return path.dirname(workspaceFilePath);
    }
    sourceMemberFullNameConflictsWithWorkspaceFullName(sourceMemberFullName, workspaceFullName) {
        const aggregateSourceMemberName = this.getAggregateFullNameFromSourceMemberName(sourceMemberFullName);
        const aggregateFullName = this.getAggregateFullNameFromWorkspaceFullName(workspaceFullName);
        return aggregateSourceMemberName === aggregateFullName;
    }
    getAggregateFullNameFromMdapiPackagePath(mdapiPackagePath) {
        const pathElements = mdapiPackagePath.split(path.sep);
        return pathElements[1];
    }
}
exports.LightningComponentBundleMetadataType = LightningComponentBundleMetadataType;

//# sourceMappingURL=lightningComponentBundleMetadataType.js.map
