"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const _ = require("lodash");
const MetadataRegistry = require("../metadataRegistry");
const defaultMetadataType_1 = require("./defaultMetadataType");
const staticResource_1 = require("../decompositionStrategy/staticResource");
const PathUtil = require("../sourcePathUtil");
const STATIC_RESOURCES_DIR = 'staticresources';
class StaticResourceMetadataType extends defaultMetadataType_1.DefaultMetadataType {
    /**
     * Returns the file path to the corresponding static resource directory based on the static
     * resource sourcePath.  E.g.,
     *   force-app/main/default/staticresources/SiteSamples/img/ --> force-app/main/default/staticresources/SiteSample
     *   force-app/main/default/staticresources/SiteSamples/img/clock.png --> force-app/main/default/staticresources/SiteSample
     *
     * @param sourcePath absolute or relative path to a static resource file or sub-directory.
     */
    resolveSourcePath(sourcePath) {
        return this.slicePath(sourcePath, STATIC_RESOURCES_DIR, 2).join(path.sep);
    }
    // Splits a file path into an array, then slices it based on a directory name and index modifier.
    slicePath(filePath, dirName, modifier = 1) {
        let filePathArray = filePath.split(path.sep);
        const index = dirName ? filePathArray.lastIndexOf(dirName) : filePathArray.length;
        return filePathArray.slice(0, Math.min(index + modifier, filePathArray.length));
    }
    getFullNameFromFilePath(filePath) {
        return this.getAggregateFullNameFromFilePath(filePath);
    }
    getAggregateFullNameFromFilePath(filePath) {
        if (filePath.endsWith(`${this.typeDefObj.ext}${MetadataRegistry.getMetadataFileExt()}`)) {
            return path.basename(StaticResourceMetadataType.removeExtensions(filePath));
        }
        const staticResource = _.last(this.slicePath(filePath, STATIC_RESOURCES_DIR, 2));
        return StaticResourceMetadataType.removeExtensions(staticResource);
    }
    getAggregateMetadataFilePathFromWorkspacePath(filePath) {
        // used to be StaticResource.getMetadataFilePathFor()
        const staticResourcesPath = this.slicePath(filePath, STATIC_RESOURCES_DIR).join(path.sep);
        const fullName = this.getFullNameFromFilePath(filePath);
        return path.join(staticResourcesPath, `${fullName}.${this.typeDefObj.ext}${MetadataRegistry.getMetadataFileExt()}`);
    }
    getOriginContentPathsForSourceConvert(metadataFilePath, workspaceVersion, unsupportedMimeTypes, forceIgnore) {
        const staticResource = new staticResource_1.StaticResource(metadataFilePath, this, workspaceVersion, undefined, unsupportedMimeTypes);
        return staticResource.getResource().then(resourcePath => Promise.resolve([resourcePath]));
    }
    getMdapiFormattedContentFileName(originContentPath, aggregateFullName) {
        return `${aggregateFullName}.${this.typeDefObj.ext}`;
    }
    mainContentFileExists(metadataFilePath) {
        const contentFilePath = PathUtil.getContentPathWithNonStdExtFromMetadataPath(metadataFilePath);
        return !_.isNil(contentFilePath);
    }
    static removeExtensions(filePath) {
        if (path.extname(filePath) === '') {
            return filePath;
        }
        else {
            return StaticResourceMetadataType.removeExtensions(path.join(path.dirname(filePath), path.basename(filePath, path.extname(filePath))));
        }
    }
    getComponentFailureWorkspaceContentPath(metadataFilePath, workspaceContentPaths) {
        const sr = new staticResource_1.StaticResource(metadataFilePath, this, undefined);
        if (sr.isExplodedArchive()) {
            const explodedDir = PathUtil.getFileName(metadataFilePath);
            return path.join(path.dirname(metadataFilePath), explodedDir);
        }
        return workspaceContentPaths[0];
    }
    shouldDeleteWorkspaceAggregate(metadataType) {
        // Handle deletes of staticResources at the subcomponent level
        return false;
    }
}
exports.StaticResourceMetadataType = StaticResourceMetadataType;

//# sourceMappingURL=staticResourceMetadataType.js.map
