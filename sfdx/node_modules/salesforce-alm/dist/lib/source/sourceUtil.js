"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const os = require("os");
const lodash_1 = require("lodash");
const aggregateSourceElement_1 = require("./aggregateSourceElement");
const metadataTypeFactory_1 = require("./metadataTypeFactory");
const core_1 = require("@salesforce/core");
const mdapiRetrieveApi_1 = require("../mdapi/mdapiRetrieveApi");
const inFolderMetadataType_1 = require("./metadataTypeImpl/inFolderMetadataType");
const ManifestCreateApi = require("./manifestCreateApi");
const srcDevUtil = require("../core/srcDevUtil");
const consts = require("../core/constants");
const MdapiPackage = require("../source/mdapiPackage");
const PathUtil = require("../source/sourcePathUtil");
const nondecomposedTypesWithChildrenMetadataType_1 = require("../source/metadataTypeImpl/nondecomposedTypesWithChildrenMetadataType");
const customLabelsMetadataType_1 = require("./metadataTypeImpl/customLabelsMetadataType");
const aggregateSourceElements_1 = require("./aggregateSourceElements");
const sourceLocations_1 = require("./sourceLocations");
core_1.Messages.importMessagesDirectory(__dirname);
/**
 * Validate the value for the 'wait' parameter and reset it as a number.
 * @param flags The command parameters (aka flags)
 * @param minWaitTime The minimum allowable time to wait
 */
exports.parseWaitParam = (flags, minWaitTime = consts.MIN_SRC_WAIT_MINUTES) => {
    if (!lodash_1.isNil(flags.wait)) {
        if (srcDevUtil.isInt(flags.wait)) {
            const wait = (flags.wait = parseInt(flags.wait, 10)); // convert to a number
            if (wait >= minWaitTime) {
                return;
            }
        }
        const errConfig = new core_1.SfdxErrorConfig('salesforce-alm', 'source', 'mdapiCliInvalidNumericParam');
        errConfig.setErrorTokens(['wait']);
        throw core_1.SfdxError.create(errConfig);
    }
};
/**
 * Validate that the org is a non-source-tracked org.
 * @param orgName The username of the org for doing the source:deploy or source:retrieve
 * @param errAction The action ('push' or 'pull') to take when the org is discovered to be a source tracked org.
 */
exports.validateNonSourceTrackedOrg = async (orgName, errAction) => {
    if (await srcDevUtil.isSourceTrackedOrg(orgName)) {
        const errConfig = new core_1.SfdxErrorConfig('salesforce-alm', 'source', 'SourceTrackedOrgError');
        errConfig.addAction('SourceTrackedOrgErrorAction', [errAction]);
        throw core_1.SfdxError.create(errConfig);
    }
};
/**
 * Validate that a manifest file path exists and is readable.
 * @param manifestPath The path to the manifest file (package.xml)
 */
exports.validateManifestPath = async (manifestPath) => {
    try {
        await core_1.fs.access(manifestPath, core_1.fs.constants.R_OK);
    }
    catch (e) {
        throw core_1.SfdxError.create('salesforce-alm', 'source', 'InvalidManifestError', [manifestPath]);
    }
};
async function createOutputDir(cmdName) {
    const logger = await core_1.Logger.child('SourceUtil');
    const targetDir = process.env.SFDX_MDAPI_TEMP_DIR || os.tmpdir();
    const tmpOutputDir = path.join(targetDir, `sdx_${cmdName}_${Date.now()}`);
    await core_1.fs.mkdirp(tmpOutputDir, core_1.fs.DEFAULT_USER_DIR_MODE);
    logger.info(`Created output directory '${tmpOutputDir}'`);
    return tmpOutputDir;
}
exports.createOutputDir = createOutputDir;
async function cleanupOutputDir(outputDir) {
    const logger = await core_1.Logger.child('SourceUtil');
    if (outputDir && !outputDir.includes(process.env.SFDX_MDAPI_TEMP_DIR)) {
        try {
            await core_1.fs.remove(outputDir);
            try {
                if (await core_1.fs.stat(`${outputDir}.zip`)) {
                    await core_1.fs.unlink(`${outputDir}.zip`);
                }
            }
            catch (err) {
                if (err.code !== 'ENOENT') {
                    logger.warn(`Could not delete the MDAPI temporary zip file ${outputDir}.zip due to: ${err.message}`);
                }
            }
        }
        catch (err) {
            logger.warn(`Could not delete the outputDir '${outputDir}' due to: ${err.message}`);
        }
    }
    else {
        logger.warn(`Did not delete the outputDir '${outputDir}' because it was set by the user`);
    }
}
exports.cleanupOutputDir = cleanupOutputDir;
/**
 * Return the aggregate source element for the specified file
 * @param {string} sourcePath the file in the workspace
 * @param sourceWorkspaceAdapter
 * @returns {AggregateSourceElement}
 */
exports.getSourceElementForFile = async function (sourcePath, sourceWorkspaceAdapter, metadataType) {
    let aggregateSourceElement;
    const mdRegistry = sourceWorkspaceAdapter.metadataRegistry;
    const sourceElementMetadataType = metadataType || metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromSourcePath(sourcePath, mdRegistry);
    if (sourceElementMetadataType) {
        // This will build an AggregateSourceElement with only the specified WorkspaceElement
        // (child element) when the metadata type has a parent.
        const _sourcePath = lodash_1.get(sourceElementMetadataType, 'typeDefObj.parent') ? sourcePath : path.dirname(sourcePath);
        const aggregateMetadataName = sourceElementMetadataType.getAggregateMetadataName();
        const aggregateFullName = sourceElementMetadataType.getAggregateFullNameFromFilePath(sourcePath);
        const key = aggregateSourceElement_1.AggregateSourceElement.getKeyFromMetadataNameAndFullName(aggregateMetadataName, aggregateFullName);
        // Get the AggregateSourceElement, which will only populate with the specified WorkspaceElement
        // when sourcePath is part of an ASE.
        const sourceElements = await sourceWorkspaceAdapter.getAggregateSourceElements(false, undefined, undefined, _sourcePath);
        const packageName = sourceWorkspaceAdapter.packageInfoCache.getPackageNameFromSourcePath(sourcePath);
        aggregateSourceElement = exports.loadSourceElement(sourceElements, key, mdRegistry, packageName);
    }
    else {
        throw core_1.SfdxError.create('salesforce-alm', 'source', 'SourcePathInvalid', [sourcePath]);
    }
    return aggregateSourceElement;
};
/**
 * Get the source elements from the source path, whether for a particular file or a directory
 */
exports.getSourceElementsFromSourcePath = async function (optionsSourcePath, sourceWorkspaceAdapter) {
    const aggregateSourceElements = new aggregateSourceElements_1.AggregateSourceElements();
    const mdRegistry = sourceWorkspaceAdapter.metadataRegistry;
    for (let sourcepath of optionsSourcePath.split(',')) {
        // resolve to an absolute path
        sourcepath = path.resolve(sourcepath.trim());
        // Throw an error if the source path isn't accessible.
        try {
            await core_1.fs.access(sourcepath, core_1.fs.constants.R_OK);
        }
        catch (e) {
            throw core_1.SfdxError.create('salesforce-alm', 'source', 'SourcePathInvalid', [sourcepath]);
        }
        // Get the MetadataType so we can resolve the path.  Some paths such as individual static
        // resources need to use a different path when getting source elements.
        const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromSourcePath(sourcepath, mdRegistry);
        if (metadataType) {
            sourcepath = metadataType.resolveSourcePath(sourcepath);
        }
        // Get a single source element or a directory of source elements and add it to the map.
        if (srcDevUtil.containsFileExt(sourcepath)) {
            const ase = await exports.getSourceElementForFile(sourcepath, sourceWorkspaceAdapter, metadataType);
            const aseKey = ase.getKey();
            const pkg = ase.getPackageName();
            if (aggregateSourceElements.has(pkg)) {
                const sourceElements = aggregateSourceElements.get(pkg);
                if (sourceElements.has(aseKey)) {
                    const _ase = sourceElements.get(aseKey);
                    _ase.addWorkspaceElement(ase.getWorkspaceElements()[0]);
                    sourceElements.set(aseKey, _ase);
                }
                else {
                    sourceElements.set(aseKey, ase);
                }
            }
            else {
                aggregateSourceElements.setIn(pkg, aseKey, ase);
            }
        }
        else {
            const sourceElementsInPath = await exports.getSourceElementsInPath(sourcepath, sourceWorkspaceAdapter);
            aggregateSourceElements.merge(sourceElementsInPath);
        }
    }
    return aggregateSourceElements;
};
/**
 * Return the specified aggregate source element or error if it does not exist
 * @param {AggregateSourceElements} sourceElements All the source elements in the workspace
 * @param {string} key The key of the particular source element we are looking for
 * @param {string} packageName
 * @param {MetadataRegistry} metadataRegistry
 * @returns {AggregateSourceElement}
 */
exports.loadSourceElement = function (sourceElements, key, metadataRegistry, packageName) {
    const aggregateSourceElement = packageName
        ? sourceElements.getSourceElement(packageName, key)
        : sourceElements.findSourceElementByKey(key);
    if (!aggregateSourceElement) {
        // Namespaces also contain '__' so only split on the first occurrence of '__'
        let [mdType, ...rest] = key.split('__');
        const mdName = rest.join('__');
        const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(mdType, metadataRegistry);
        if (!metadataType) {
            throw core_1.SfdxError.create('salesforce-alm', 'source', 'MetadataTypeDoesNotExist', [mdType]);
        }
        const hasParentType = metadataType.getMetadataName() !== metadataType.getAggregateMetadataName();
        if (hasParentType) {
            //In this case, we are dealing with a decomposed subtype, so need to check for a parent
            const parentName = metadataType.getAggregateMetadataName();
            const parentMetadataType = metadataTypeFactory_1.MetadataTypeFactory.getAggregateMetadataType(parentName, metadataRegistry);
            const parentFullName = metadataType.getAggregateFullNameFromWorkspaceFullName(mdName);
            const newKey = aggregateSourceElement_1.AggregateSourceElement.getKeyFromMetadataNameAndFullName(parentMetadataType.getAggregateMetadataName(), parentFullName);
            return exports.loadSourceElement(sourceElements, newKey, metadataRegistry, packageName);
        }
        else if (metadataType instanceof inFolderMetadataType_1.InFolderMetadataType) {
            mdType = MdapiPackage.convertFolderTypeKey(mdType);
            return exports.loadSourceElement(sourceElements, `${mdType}__${mdName}`, metadataRegistry, packageName);
        }
        else if (metadataType instanceof nondecomposedTypesWithChildrenMetadataType_1.NondecomposedTypesWithChildrenMetadataType) {
            const mdType = metadataType.getMetadataName();
            let name = `${mdType}__${mdName.split('.')[0]}`;
            if (metadataType instanceof customLabelsMetadataType_1.CustomLabelsMetadataType) {
                // for now, all CustomLabels are in CustomLabels.labels.meta-xml.
                // the key for the ASE is then CustomLabels_CustomLabels
                // it will deploy all CustomLabels, regardless of what is specified in the manifest
                name = `${mdType}__${mdType}`;
            }
            if (name === key) {
                // the name isn't changing which causes a max stack call size error,
                const errConfig = new core_1.SfdxErrorConfig('salesforce-alm', 'source_deploy', 'SourceElementDoesNotExist');
                errConfig.setErrorTokens([mdType, mdName]);
                throw core_1.SfdxError.create(errConfig);
            }
            return exports.loadSourceElement(sourceElements, name, metadataRegistry, packageName);
        }
        else {
            const errConfig = new core_1.SfdxErrorConfig('salesforce-alm', 'source_deploy', 'SourceElementDoesNotExist');
            errConfig.setErrorTokens([mdType, mdName]);
            throw core_1.SfdxError.create(errConfig);
        }
    }
    return aggregateSourceElement;
};
/**
 * Return the aggregate source elements found in the provided source path
 * @param {Array<string>} sourcePath The path to look for source elements in
 * @param sourceWorkspaceAdapter
 * @returns {AggregateSourceElements}
 */
exports.getSourceElementsInPath = async function (sourcePath, sourceWorkspaceAdapter) {
    return sourceWorkspaceAdapter.getAggregateSourceElements(false, undefined, undefined, sourcePath);
};
/**
 * Convert the argument into an array datatype
 * @param arrayOrObjectOrUndefined
 * @returns Array
 */
exports.toArray = function (arrayOrObjectOrUndefined) {
    if (!arrayOrObjectOrUndefined) {
        return [];
    }
    else if (Array.isArray(arrayOrObjectOrUndefined)) {
        return arrayOrObjectOrUndefined;
    }
    else {
        return [arrayOrObjectOrUndefined];
    }
};
/**
 * Parse the manifest file and create a list ManifestEntry objects.
 * @param manifestPath {string} The filepath for the manifest
 * @returns {ManifestEntry[]} An array for ManifestEntry objects from the manifest.
 */
exports.parseToManifestEntriesArray = async function (manifestPath) {
    const entries = [];
    const options = {
        unpackaged: manifestPath
    };
    return mdapiRetrieveApi_1.MdRetrieveApi._getPackageJson(undefined, options).then(manifestJson => {
        exports.toArray(manifestJson.types).forEach(type => {
            if (!type.name) {
                const errConfig = new core_1.SfdxErrorConfig('salesforce-alm', 'source', 'IllFormattedManifest');
                errConfig.setErrorTokens(['; <name> is missing']);
                throw core_1.SfdxError.create(errConfig);
            }
            exports.toArray(type.members).forEach(member => {
                const _member = PathUtil.replaceForwardSlashes(member);
                entries.push({
                    type: type.name,
                    name: _member
                });
            });
        });
        return entries;
    });
};
/**
 * Parse manifest entry strings into an array of ManifestEntry objects
 * @param arg {string} The entry string; e.g., "ApexClass, CustomObject:MyObjectName"
 */
exports.parseManifestEntries = function (entries) {
    if (entries) {
        const mdParamArray = entries.split(',');
        return mdParamArray.map(md => {
            const [mdType, ...rest] = md.split(':');
            const mdName = rest.length ? rest.join(':') : '*';
            return { type: mdType.trim(), name: PathUtil.replaceForwardSlashes(mdName.trim()) };
        });
    }
    return null;
};
/**
 * Converts SourceOptions.metadata into a package manifest for a given org.
 * @param org { any } The org
 * @param options { SourceOptions } The source options containing the metadata
 * @returns {Promise<string | null>} A path to the created manifest or null of options or options.metadata is null.
 */
exports.toManifest = async function (org, options, tmpOutputDir) {
    if (options && options.metadata) {
        const entries = exports.parseManifestEntries(options.metadata);
        if (entries != null) {
            // Create a manifest and update the options with the manifest file.
            options.manifest = (await exports.createManifest(org, options, entries, tmpOutputDir)).file;
            return options.manifest;
        }
        else {
            return null;
        }
    }
    return null;
};
/**
 * Function to create a manifest for a given org
 * @param org {AnyJson} An org
 * @param options {SourceOptions} Source options
 * @param mdPairs {ManifestEntry[]} Array of metadata items
 * @returns A package.xml manifest
 */
exports.createManifest = async function (org, options, mdPairs = [], tmpOutputDir) {
    if (!org || !options) {
        return null;
    }
    const manifestApi = new ManifestCreateApi(org);
    // Create the package.xml in the temp dir
    const manifestOptions = Object.assign({}, options, {
        outputdir: tmpOutputDir
    });
    return manifestApi.createManifest(manifestOptions, null, mdPairs);
};
/**
 * Used to determine if an error is the result of parsing bad XML. If so return a new parsing error.
 * @param path The file path.
 * @param error The error to inspect.
 */
exports.checkForXmlParseError = function (path, error) {
    if (path && error instanceof core_1.SfdxError && error.name === `xmlParseErrorsReported`) {
        const data = error.data || [];
        const message = `${path}:${os.EOL}${data.reduce((messages, message) => `${messages}${os.EOL}${message.message}`, '')}`;
        return core_1.SfdxError.create('salesforce-alm', 'source', 'XmlParsingError', [message]);
    }
    return error;
};
/**
 * @param options
 */
exports.containsMdBundle = function (options) {
    if (options.metadata) {
        // for retreiveFromMetadata
        return options.metadata.indexOf('Bundle') >= 0;
    }
    else {
        // for retrieveFromSourcepath
        for (let pair of options) {
            if (pair.type.indexOf('Bundle') >= 0) {
                return true;
            }
        }
        return false;
    }
};
/**
 * sObjects and standard fields aren't returned when polling for SourceMembers, so
 * this will remove sObjects/sFields from the pushResult so that only
 * source tracked metadata types are inserted into the maxRevision.json.
 * @param successes the success of the push or pull result
 * @param {MaxRevision} maxRevision is the class used to query SourceMembers
 * @param pollTimeLimit the number of seconds to poll for SourceMembers before timing out
 * @param fromRevision the RevisionCounter number from which to poll for SourceMembers
 * @returns {Promise<SourceMember[]>}
 */
exports.getSourceMembersFromResult = async function (successes, maxRevision, pollTimeLimit) {
    // reduce to just "MemberName" aka fullName
    const successNames = successes
        .filter(c => !c.fullName.includes('xml'))
        .map(c => {
        return [c].concat(sourceLocations_1.SourceLocations.nonDecomposedElementsIndex.getElementsByMetadataFilePath(c.filePath));
    })
        .reduce((x, y) => x.concat(y), [])
        .map(c => decodeURIComponent(c.fullName));
    if (pollTimeLimit && pollTimeLimit >= 0) {
        await maxRevision.pollForSourceMembers(successNames, pollTimeLimit);
    }
    const allMembers = await maxRevision.retrieveAllSourceMembers();
    // reduce from SourceMember to just MemberName
    const allMemberNames = allMembers.map(m => m.MemberName);
    // remove the different items, from what the query returned vs local source tracking
    const diffedMembers = allMemberNames.filter(al => successNames.includes(al.split('/')[0]));
    // filter the SourceMember list to just include those in the diffedMembers
    return allMembers.filter(member => diffedMembers.includes(member.MemberName));
};

//# sourceMappingURL=sourceUtil.js.map
