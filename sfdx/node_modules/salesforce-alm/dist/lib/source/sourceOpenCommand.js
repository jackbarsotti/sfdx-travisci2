"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const MetadataRegistry = require("./metadataRegistry");
const OrgOpenCommand = require("../org/orgOpenCommand");
const path = require("path");
const fs = require("fs");
const request = require("request");
const Display = require("../force-cli/force-cli-display");
const Config = require("../force-cli/force-cli-config");
const Messages = require("../force-cli/force-cli-messages");
const logApi = require("../core/logApi");
let logger;
class SourceOpenCommand {
    constructor() {
        logger = logApi.child('source:open');
    }
    validate(context) { }
    async execute(context) {
        if (context && context.flags && context.flags.sourcefile) {
            try {
                fs.realpathSync(context.flags.sourcefile);
                let editOp = new SourceOpenOperation(context);
                return await editOp.execute();
            }
            catch (err) {
                logger.error(err);
                throw Error(err.message);
            }
        }
        else {
            throw Error(context.command);
        }
    }
}
exports.SourceOpenCommand = SourceOpenCommand;
class SourceOpenOperation {
    constructor(context, factory) {
        this.context = context;
        if (factory) {
            this.factory = factory;
        }
    }
    set factory(factory) {
        this._factory = factory;
    }
    get factory() {
        if (this._factory === undefined) {
            try {
                let metadataFactory = new MetadataRegistry(this.context.org);
                this._factory = new StrategyFactory(this.context, metadataFactory);
            }
            catch (e) {
                throw remapError(e);
            }
        }
        return this._factory;
    }
    async execute() {
        try {
            let strategy = this.factory.strategize();
            let url = await strategy.open();
            if (this.context.flags.json) {
                return url;
            }
            else {
                Display.info(Messages.get('SourceOpenCommandHumanSuccess', url.orgId, url.username, url.url));
            }
        }
        catch (e) {
            throw Error(Messages.get('SourceOpenCommandHumanError', e.message));
        }
    }
}
exports.SourceOpenOperation = SourceOpenOperation;
function remapError(e) {
    let stack = e.stack;
    if (stack.includes('MetadataRegistry.getTypeDefsByExtension')) {
        return new Error(Messages.get('SourceOpenCommandUnpushedError'));
    }
    else {
        return e;
    }
}
exports.remapError = remapError;
async function isSalesforceOneEnabled(cmd, requestApi, context) {
    let localContext = Object.assign({}, context, {
        flags: {
            urlonly: true,
            path: 'one/one.app'
        }
    });
    let url = await cmd.execute(await cmd.validate(localContext));
    return new Promise((resolve, reject) => {
        requestApi(url.url, (error, response, body) => {
            if (body && !body.includes('lightning/access/orgAccessDenied.jsp')) {
                resolve(true);
            }
            else {
                resolve(false);
            }
        });
    });
}
exports.isSalesforceOneEnabled = isSalesforceOneEnabled;
class StrategyFactory {
    constructor(context, metadataRegistry) {
        this.context = context;
        this.metadataRegistry = metadataRegistry;
    }
    strategize() {
        let absoluteFilePath = path.resolve(this.context.flags.sourcefile);
        let type = this.metadataRegistry.getTypeDefinitionByFileName(absoluteFilePath);
        if (type) {
            if (type.metadataName === 'FlexiPage') {
                return new FlexipageStrategy(this.context, new OrgOpenCommand());
            }
        }
        return new DefaultStrategy(this.context, new OrgOpenCommand());
    }
}
exports.StrategyFactory = StrategyFactory;
class FlexipageStrategy {
    constructor(context, cmd) {
        this.context = context;
        this.cmd = cmd;
    }
    async deriveFlexipageURL(flexipage) {
        let connection = await Config.getActiveConnection(this.context);
        try {
            let queryResult = await connection.tooling.query(`SELECT id FROM flexipage WHERE DeveloperName='${flexipage}'`);
            if (queryResult.totalSize === 1 && queryResult.records) {
                let record = queryResult.records[0];
                return record.Id;
            }
            else {
                return FlexipageStrategy.NO_ID;
            }
        }
        catch (err) {
            return FlexipageStrategy.NO_ID;
        }
    }
    async setUpOpenContext() {
        let openContext = Object.assign({}, this.context);
        let id = await this.deriveFlexipageURL(path.basename(this.context.flags.sourcefile, '.flexipage-meta.xml'));
        let salesforceOne = await exports.isSalesforceOneEnabled(this.cmd, request, openContext);
        if (id) {
            openContext.flags.path = `/visualEditor/appBuilder.app?pageId=${id}`;
        }
        else {
            if (salesforceOne) {
                openContext.flags.path = '/one/one.app#/setup/FlexiPageList/home';
            }
            else {
                openContext.flags.path = '_ui/flexipage/ui/FlexiPageFilterListPage';
            }
        }
        return openContext;
    }
    async open() {
        let context = await this.cmd.validate(await this.setUpOpenContext());
        return await this.cmd.execute(context);
    }
}
exports.FlexipageStrategy = FlexipageStrategy;
FlexipageStrategy.NO_ID = undefined;
class DefaultStrategy {
    constructor(context, cmd) {
        this.context = context;
        this.cmd = cmd;
    }
    async open() {
        return await this.cmd.execute(await this.cmd.validate(this.context));
    }
}
exports.DefaultStrategy = DefaultStrategy;

//# sourceMappingURL=sourceOpenCommand.js.map
