"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const SourceUtil = require("./sourceUtil");
const metadataTypeFactory_1 = require("./metadataTypeFactory");
const core_1 = require("@salesforce/core");
const util = require("util");
const path = require("path");
const messages = require("../../lib/messages");
const aggregateSourceElements_1 = require("./aggregateSourceElements");
const message = messages();
class SourceElementsResolver {
    constructor(org, sourceWorkSpaceAdapter) {
        this.sourceWorkSpaceAdapter = sourceWorkSpaceAdapter;
        this.org = org;
    }
    /**
     *
     * @param optionsManifest - path to package.xml
     * @return {Map} aggregateSourceElements
     */
    async getSourceElementsFromManifest(optionsManifest) {
        const typeNamePairs = await SourceUtil.parseToManifestEntriesArray(optionsManifest);
        return this.parseTypeNamePairs(typeNamePairs, await this.sourceWorkSpaceAdapter.getAggregateSourceElements(false));
    }
    /**
     * Filters the elements based on the manifest file.
     * @param typeNamePairs - type name pairs from the manifest file
     * @param sourceElements
     * @return {Map} aggregateSoureElements
     */
    parseTypeNamePairs(typeNamePairs, sourceElements) {
        let aggregateSourceElements = new aggregateSourceElements_1.AggregateSourceElements();
        typeNamePairs.forEach((entry) => {
            if (entry.name.includes('*')) {
                let keyMetadataType = entry.type;
                const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(keyMetadataType, this.sourceWorkSpaceAdapter.metadataRegistry);
                if (!metadataType) {
                    throw core_1.SfdxError.create('salesforce-alm', 'source', 'UnsupportedType', [keyMetadataType]);
                }
                if (metadataType.getMetadataName() !== metadataType.getAggregateMetadataName()) {
                    // In this case we are dealing with a decomposed item, so reload using the parent name
                    keyMetadataType = metadataType.getAggregateMetadataName();
                }
                sourceElements.forEach(elements => {
                    const wildcards = [...elements.keys()]
                        .filter(item => item.includes(keyMetadataType))
                        .map((typeAnyName) => {
                        let [mdType, ...rest] = typeAnyName.split('__');
                        const mdName = rest.join('__');
                        return {
                            type: mdType,
                            name: mdName
                        };
                    });
                    aggregateSourceElements.merge(this.parseTypeNamePairs(wildcards, sourceElements));
                });
            }
            else {
                const ase = SourceUtil.loadSourceElement(sourceElements, `${entry.type}__${entry.name}`, this.sourceWorkSpaceAdapter.metadataRegistry);
                aggregateSourceElements.setIn(ase.getPackageName(), ase.getKey(), ase);
            }
        });
        return aggregateSourceElements;
    }
    /**
     *
     * @param options - any{}
     * @param aggregateSourceElements - any empty array of type aggregateSoureElements
     * @param tmpOutputDir
     */
    async getSourceElementsFromMetadata(options, aggregateSourceElements, tmpOutputDir) {
        tmpOutputDir = util.isNullOrUndefined(tmpOutputDir)
            ? await SourceUtil.createOutputDir('decomposition')
            : tmpOutputDir;
        const manifestPath = await SourceUtil.toManifest(this.org, options, tmpOutputDir);
        const isPathABundleError = path.extname(options.metadata).length > 0 && SourceUtil.containsMdBundle(options);
        if (isPathABundleError) {
            let err = core_1.SfdxError.create('salesforce-alm', 'source', 'SourcePathInvalid', [options.metadata]);
            const sfdxError = (core_1.SfdxError.wrap(err).message = message.getMessage('PathToBundleComponenet'));
            throw sfdxError;
        }
        if (manifestPath) {
            aggregateSourceElements = await this.getSourceElementsFromManifest(manifestPath);
        }
        else {
            throw core_1.SfdxError.create('salesforce-alm', 'source', 'failedToCreateManifest');
        }
        return aggregateSourceElements;
    }
}
exports.SourceElementsResolver = SourceElementsResolver;

//# sourceMappingURL=sourceElementsResolver.js.map
