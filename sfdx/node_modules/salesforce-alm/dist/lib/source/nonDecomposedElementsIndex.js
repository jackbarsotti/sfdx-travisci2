"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const path_1 = require("path");
const xml2js = require("xml2js");
const MetadataRegistry = require("./metadataRegistry");
const packageInfoCache_1 = require("./packageInfoCache");
const MaxRevision_1 = require("./MaxRevision");
const NON_DECOMPOSED_CONFIGS = {
    CustomLabels: [
        {
            childType: 'CustomLabel',
            xmlTag: 'CustomLabels.labels',
            namePath: 'fullName[0]'
        }
    ]
};
/**
 * NonDecomposedElementsIndex maintains an index of non-decomposed elements (e.g. CustomLabel) at
 * <project_dir>/.sfdx/orgs/<username>/nonDecomposedElementsIndex.json.
 *
 * The purpose of this is to be able to figure out which elements belong to which file. So for example,
 * if we have CustomLabels files in two separate packages, we can use this index to determine which
 * labels to put into the package.xml when executing a retrieve or a pull.
 *
 * We use the NON_DECOMPOSED_CONFIGS to determine which metadata types need to be read and stored into the index.
 *   - The keys (e.g. CustomLabels) are the aggregate metadata types. This tells us which meta files we need to read.
 *   - childType refers to the metadata type of the elements inside the meta file
 *   - xmlTag tells us where to find the elements inside the xml
 *   - namePath tells us where to find the name of the element
 */
class NonDecomposedElementsIndex extends core_1.ConfigFile {
    constructor() {
        super(...arguments);
        this.includedFiles = new Set();
        this.hasChanges = false;
    }
    static async getInstance(options) {
        if (!this._instances[options.username]) {
            this._instances[options.username] = await NonDecomposedElementsIndex.create(options);
        }
        return this._instances[options.username];
    }
    getFileName() {
        return 'nonDecomposedElementsIndex.json';
    }
    async init() {
        this.options.filePath = path_1.join('.sfdx', 'orgs', this.options.username);
        this.options.filename = this.getFileName();
        this.logger = await core_1.Logger.child(this.constructor.name);
        this.metadataRegistry = this.options.metadataRegistry;
        this.packageInfoCache = packageInfoCache_1.PackageInfoCache.getInstance();
        this.maxRevision = await MaxRevision_1.MaxRevision.getInstance({ username: this.options.username });
        await super.init();
        this.populateIncludedFiles();
    }
    populateIncludedFiles() {
        this.values().forEach(v => this.includedFiles.add(v.metadataFilePath));
    }
    async addElement(metadataName, fullName, sourcePath) {
        const key = MetadataRegistry.getMetadataKey(metadataName, fullName);
        const value = {
            fullName,
            type: metadataName,
            metadataFilePath: sourcePath
        };
        if (!this.has(key)) {
            this.set(key, value);
        }
    }
    getMetadataFilePath(key) {
        const value = this.get(key);
        return value ? value.metadataFilePath : null;
    }
    /**
     * Returns true is the metadata type contains non-decomposed elements
     * that we want to put into the index.
     */
    isNonDecomposedElement(metadataName) {
        return NonDecomposedElementsIndex.isSupported(metadataName);
    }
    static isSupported(metadataName) {
        return NON_DECOMPOSED_CONFIGS.hasOwnProperty(metadataName);
    }
    /**
     * Returns true if the provided sourcePath is in this.includedFiles.
     * If a file is in this.includedFiles, that means that the index has
     * already read that file
     */
    isIncludedFile(sourcePath) {
        return this.includedFiles.has(sourcePath);
    }
    /**
     * Returns true if the file has NOT changed or is NOT new
     */
    shouldSkip(sourcePathInfo) {
        return !(sourcePathInfo.isChanged() || sourcePathInfo.isNew()) && this.isIncludedFile(sourcePathInfo.sourcePath);
    }
    /**
     * Adds the non-decomposed elements within a sourcePath to the index
     *
     * If the given sourcePath is supported, then we:
     *  - read the xml
     *  - parse the xml for the non-decomposed elements
     *  - add all those elements to the index
     *
     * We skip this process if:
     *  - the sourcePath belongs to a metadata type that doesn't have non-decomposed elements
     *  - OR the sourcePath hasn't changed since the last time we read it
     *
     * Set the refresh flag to true if you want to force update the index
     */
    async handleDecomposedElements(sourcePathInfo, refresh = false) {
        if (!refresh && this.shouldSkip(sourcePathInfo))
            return;
        const metadataType = this.metadataRegistry.getTypeDefinitionByFileName(sourcePathInfo.sourcePath);
        const configs = NON_DECOMPOSED_CONFIGS[metadataType.metadataName];
        const contents = await this.readXmlAsJson(sourcePathInfo.sourcePath);
        for (const config of configs) {
            const elements = ts_types_1.get(contents, config.xmlTag, []);
            for (const element of elements) {
                const fullName = ts_types_1.get(element, config.namePath);
                if (fullName) {
                    await this.addElement(metadataType.metadataName, fullName, sourcePathInfo.sourcePath);
                }
            }
        }
        this.write();
    }
    /**
     * Unsets elements with a metadataFilePath that matches the provided sourcePath
     */
    clearElements(sourcePath) {
        const matchingElements = this.getElementsByMetadataFilePath(sourcePath);
        matchingElements.forEach(element => {
            const key = MetadataRegistry.getMetadataKey(element.type, element.fullName);
            this.unset(key);
        });
    }
    /**
     * Returns JSON representation of an xml file
     */
    async readXmlAsJson(sourcePath) {
        const contents = await core_1.fs.readFile(sourcePath);
        return new Promise(resolve => {
            xml2js.parseString(contents.toString(), async (err, res) => {
                if (err) {
                    throw core_1.SfdxError.create('salesforce-alm', 'source', 'XmlParsingError', [`; ${err.message}`]);
                }
                else {
                    resolve(res);
                }
            });
        });
    }
    /**
     * Given an array of sourceMmebers, find all sourceMembers that are live in the same file location.
     * For example, given a custom label this will return all custom labels that live in the same CustomLabels
     * meta file.
     */
    getRelatedNonDecomposedElements(sourceMembers) {
        const elements = [];
        const seen = new Set();
        const contents = this.values();
        const isRelatedElement = function (existingElement, comparisonElement) {
            return (existingElement.metadataFilePath === comparisonElement.metadataFilePath &&
                existingElement.fullName !== comparisonElement.fullName &&
                !seen.has(comparisonElement.fullName));
        };
        for (const sourceMember of sourceMembers) {
            const metadataType = this.metadataRegistry.getTypeDefinitionByMetadataName(sourceMember.MemberType);
            if (metadataType && NonDecomposedElementsIndex.isSupported(metadataType.metadataName)) {
                const key = MetadataRegistry.getMetadataKey(metadataType.metadataName, sourceMember.MemberName);
                const element = this.get(key);
                contents.forEach(item => {
                    const shouldAdd = this.has(key) ? isRelatedElement(element, item) : this.elementBelongsToDefaultPackage(item);
                    if (shouldAdd) {
                        seen.add(item.fullName);
                        const sourceMemberFromMaxRevision = this.maxRevision.getSourceMember(key);
                        const isNameObsolete = sourceMemberFromMaxRevision ? sourceMemberFromMaxRevision.isNameObsolete : false;
                        elements.push({
                            MemberType: sourceMember.MemberType,
                            MemberName: item.fullName,
                            IsNameObsolete: isNameObsolete
                        });
                    }
                });
            }
        }
        return elements;
    }
    /**
     * Returns all elements in the index that have a given metadataFilePath
     */
    getElementsByMetadataFilePath(metadataFilePath) {
        if (!this.isIncludedFile(metadataFilePath)) {
            return [];
        }
        const elements = [...this.values()];
        const matches = elements.filter(element => {
            return element.metadataFilePath === metadataFilePath;
        });
        return matches;
    }
    /**
     * Refreshes the index IF the inboundFiles contain any paths that have
     * been previously added to the index.
     */
    async maybeRefreshIndex(inboundFiles) {
        const results = inboundFiles.filter(c => !c.fullName.includes('xml'));
        const supportedTypes = results.filter(r => {
            return NonDecomposedElementsIndex.isSupported(decodeURIComponent(r.fullName));
        });
        if (supportedTypes.length) {
            const sourcePaths = supportedTypes.map(r => r.filePath);
            return this.refreshIndex(sourcePaths);
        }
    }
    /**
     * Refreshes the index using the provided sourcePaths. If no sourcePaths
     * are provided then it will default to refreshing files that have already
     * been indexed (this.includedFiles)
     */
    async refreshIndex(sourcePaths) {
        const paths = sourcePaths || this.includedFiles;
        for (const sourcePath of paths) {
            this.clearElements(sourcePath);
            await this.handleDecomposedElements({ sourcePath }, true);
        }
    }
    /**
     * Returns true if the given nonDecomposedElements belongs to the default package
     */
    elementBelongsToDefaultPackage(nonDecomposedElement) {
        const defaultPackage = this.packageInfoCache.getDefaultPackage().name;
        const elementPackage = this.packageInfoCache.getPackageNameFromSourcePath(nonDecomposedElement.metadataFilePath);
        return defaultPackage === elementPackage;
    }
    async write() {
        if (!this.hasChanges)
            return;
        this.hasChanges = false;
        return super.write();
    }
    get(key) {
        return super.get(key);
    }
    set(key, value) {
        super.set(key, value);
        this.includedFiles.add(value.metadataFilePath);
        this.hasChanges = true;
        return this.getContents();
    }
    values() {
        return super.values();
    }
}
exports.NonDecomposedElementsIndex = NonDecomposedElementsIndex;
NonDecomposedElementsIndex._instances = {};

//# sourceMappingURL=nonDecomposedElementsIndex.js.map
