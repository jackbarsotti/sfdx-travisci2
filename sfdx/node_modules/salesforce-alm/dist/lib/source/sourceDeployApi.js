"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const cli_ux_1 = require("cli-ux");
// Node
const path = require("path");
const fsExtra = require("fs-extra");
// Local
const MetadataRegistry = require("./metadataRegistry");
const MdapiDeployApi = require("../mdapi/mdapiDeployApi");
const syncCommandHelper = require("./syncCommandHelper");
const sourceState = require("./sourceState");
const core_1 = require("@salesforce/core");
const metadataTypeFactory_1 = require("./metadataTypeFactory");
const sourceDeployApiBase_1 = require("./sourceDeployApiBase");
const SourceUtil = require("./sourceUtil");
const aggregateSourceElements_1 = require("./aggregateSourceElements");
const PathUtils = require("./sourcePathUtil");
const os = require("os");
const consts = require("../core/constants");
const sourceWorkspaceAdapter_1 = require("./sourceWorkspaceAdapter");
const sourceElementsResolver_1 = require("./sourceElementsResolver");
class SourceDeployApi extends sourceDeployApiBase_1.SourceDeployApiBase {
    constructor() {
        super(...arguments);
        this.DELETE_NOT_SUPPORTED_IN_CONTENT = ['StaticResource'];
    }
    // @todo we shouldn't cross the command api separation by re-using cli options as dependencies for the api.
    async doDeploy(options) {
        let aggregateSourceElements = new aggregateSourceElements_1.AggregateSourceElements();
        this.isDelete = options.delete;
        this.logger = await core_1.Logger.child('SourceDeployApi');
        this.isAsync = options.wait === consts.MIN_SRC_DEPLOY_WAIT_MINUTES;
        // Only put SWA in stateless mode when sourcepath param is used.
        const mode = options.sourcepath && sourceWorkspaceAdapter_1.SourceWorkspaceAdapter.modes.STATELESS;
        this.logger.debug(`mode: ${mode}`);
        const defaultPackagePath = this.orgApi.config.getAppConfig().defaultPackagePath;
        const swaOptions = {
            org: this.orgApi,
            metadataRegistryImpl: MetadataRegistry,
            defaultPackagePath: defaultPackagePath,
            fromConvert: true,
            sourceMode: mode
        };
        this.swa = await sourceWorkspaceAdapter_1.SourceWorkspaceAdapter.create(swaOptions);
        SourceDeployApi.totalNumberOfPackages = this.swa.packageInfoCache.packageNames.length;
        let tmpOutputDir = await SourceUtil.createOutputDir('sourceDeploy');
        try {
            const sourceElementsResolver = new sourceElementsResolver_1.SourceElementsResolver(this.orgApi, this.swa);
            if (options.sourcepath) {
                this.logger.info(`Deploying metadata in sourcepath '${options.sourcepath}' from org: '${this.orgApi.name}'`);
                aggregateSourceElements = await SourceUtil.getSourceElementsFromSourcePath(options.sourcepath, this.swa);
            }
            else if (options.manifest) {
                this.logger.info(`Deploying metadata in manifest '${options.manifest}' from org: '${this.orgApi.name}'`);
                aggregateSourceElements = await sourceElementsResolver.getSourceElementsFromManifest(options.manifest);
            }
            else if (options.metadata) {
                aggregateSourceElements = await sourceElementsResolver.getSourceElementsFromMetadata(options, aggregateSourceElements, tmpOutputDir);
            }
            else if (options.validateddeployrequestid) {
                // this is a quick deploy
                return new MdapiDeployApi(this.orgApi).deploy(options);
            }
            else {
                // This should never happen but just a little OC - 'else if' without an 'else'
                throw core_1.SfdxError.create('salesforce-alm', 'source', 'missingScopeOption');
            }
            SourceDeployApi.packagesDeployed = aggregateSourceElements.size;
            let _handleDeleteResult = false;
            if (this.isDelete) {
                if (options.sourcepath) {
                    _handleDeleteResult = await this._handleDelete(options.noprompt, aggregateSourceElements, options.sourcepath);
                }
                else {
                    //if it is the metadata option, options.sourcepath was empty. Create a path to the "source" from the MD name
                    _handleDeleteResult = await this._handleDelete(options.noprompt, aggregateSourceElements, path.join(this.swa.defaultSrcDir, 'aura', options.metadata.split(':').pop()));
                }
                if (!_handleDeleteResult) {
                    return { outboundFiles: [], userCanceled: true };
                }
            }
            if (isNaN(options.wait)) {
                options.wait = this.force.config.getConfigContent().defaultSrcWaitMinutes;
            }
            if (!aggregateSourceElements.isEmpty()) {
                try {
                    // Create a temp directory
                    options.deploydir = tmpOutputDir;
                    options.ignorewarnings = options.ignorewarnings || this.isDelete;
                    if (!options.checkonly) {
                        await this._doLocalDelete(aggregateSourceElements);
                    }
                    const result = await this.convertAndDeploy(options, this.swa, aggregateSourceElements, this.isDelete);
                    // If we are only checking the metadata deploy, return what `mdapi:deploy` returns.
                    // Otherwise process results and return similar to `source:push`
                    if (options.checkonly || this.isAsync) {
                        return result;
                    }
                    else {
                        return await this._processResults(result, aggregateSourceElements, options.deploydir);
                    }
                }
                finally {
                    // Remove the sourcePathInfos.json file and delete any temp dirs
                    this.orgApi.getSourcePathInfos().delete();
                    await SourceUtil.cleanupOutputDir(this.tmpBackupDeletions);
                }
            }
            else {
                return { outboundFiles: [] };
            }
        }
        finally {
            await SourceUtil.cleanupOutputDir(tmpOutputDir);
        }
    }
    async _doLocalDelete(ases) {
        this.tmpBackupDeletions = await SourceUtil.createOutputDir('sourceDelete');
        const cleanedCache = new Map();
        ases.getAllSourceElements().forEach((ase) => {
            ase
                .getPendingDeletedWorkspaceElements()
                .forEach(we => fsExtra.copySync(we.getSourcePath(), path.join(this.tmpBackupDeletions, path.basename(we.getSourcePath()))));
            ase.commitDeletes([]);
            const dirname = path.dirname(ase.getMetadataFilePath());
            if (!cleanedCache.get(dirname)) {
                // This should only be called once per type. For example if there are 1000 static resources then
                // cleanEmptyDirs should be called once not 1000 times.
                PathUtils.cleanEmptyDirs(dirname);
                cleanedCache.set(dirname, true);
            }
        });
    }
    async _handleDelete(noprompt, ases, sourcepath) {
        let pendingDelPathsForPrompt = [];
        const typedefObj = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromSourcePath(sourcepath, this.swa.metadataRegistry);
        const metadataType = typedefObj ? typedefObj.getMetadataName() : null;
        /**delete of static resources file is not supported by cli */
        if (this.DELETE_NOT_SUPPORTED_IN_CONTENT.includes(metadataType)) {
            const data = fsExtra.statSync(sourcepath);
            if (data.isFile()) {
                throw core_1.SfdxError.create('salesforce-alm', 'source', 'StaticResourceDeleteError');
            }
        }
        ases.getAllSourceElements().forEach(ase => {
            ase.getWorkspaceElements().some(we => {
                const type = we.getMetadataName();
                const sourceMemberMetadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(type, this.swa.metadataRegistry);
                const shouldDeleteWorkspaceAggregate = sourceMemberMetadataType.shouldDeleteWorkspaceAggregate(type);
                if (shouldDeleteWorkspaceAggregate) {
                    ase.markForDelete();
                    return true;
                }
                else {
                    // the type is decomposed and we only want to delete components of an aggregate element
                    const sourcepaths = sourcepath.split(',');
                    if (sourcepaths.some(sp => we.getSourcePath().includes(sp.trim()))) {
                        we.setState(sourceState.DELETED);
                        ase.addPendingDeletedWorkspaceElement(we);
                    }
                }
            });
            pendingDelPathsForPrompt = pendingDelPathsForPrompt.concat(ase.getPendingDeletedWorkspaceElements().map(el => `${os.EOL}${el.getSourcePath()}`));
        });
        if (noprompt || pendingDelPathsForPrompt.length === 0) {
            return true;
        }
        return this._handlePrompt(pendingDelPathsForPrompt);
    }
    async _handlePrompt(pathsToPrompt) {
        // @todo this prompt should no be in the API. Need to remove.
        const messages = core_1.Messages.loadMessages('salesforce-alm', 'source_delete');
        const promptMessage = messages.getMessage('sourceDeletePrompt', [pathsToPrompt]);
        const answer = await cli_ux_1.default.prompt(promptMessage);
        return answer.toUpperCase() === 'YES' || answer.toUpperCase() === 'Y';
    }
    async _processResults(result, aggregateSourceElements, deployDir) {
        if (result.success && result.details.componentFailures) {
            this.removeFailedAggregates(result.details.componentFailures, aggregateSourceElements, this.swa.packageInfoCache);
        }
        // We need to check both success and status because a status of 'SucceededPartial' returns success === true even though rollbackOnError is set.
        if (result.success && result.status === 'Succeeded') {
            const isNonDestructiveChangeDelete = this.isDelete && !fsExtra.existsSync(`${deployDir}${path.sep}destructiveChangesPost.xml`);
            result.outboundFiles = this.getOutboundFiles(aggregateSourceElements, isNonDestructiveChangeDelete);
            return result;
        }
        else {
            // throw the error that is created by _setupDeployFail
            throw await this._setupDeployFail(result, aggregateSourceElements);
        }
    }
    async _setupDeployFail(result, aggSourceElements) {
        const deployFailed = new Error();
        if (result.timedOut) {
            deployFailed.name = 'PollingTimeout';
        }
        else {
            deployFailed.name = 'DeployFailed';
            deployFailed.failures = syncCommandHelper.getDeployFailures(result, aggSourceElements, this.swa.metadataRegistry);
        }
        if (result.success && result.status === 'SucceededPartial') {
            deployFailed.outboundFiles = this.getOutboundFiles(aggSourceElements);
        }
        if (this.isDelete) {
            await this._revertDeletions(aggSourceElements);
            const messages = core_1.Messages.loadMessages('salesforce-alm', 'source_delete');
            deployFailed.message = messages.getMessage('sourceDeleteFailure');
        }
        return deployFailed;
    }
    // Revert all deletions since something went wrong and they were not deleted server side.
    // This copies all the files from the temporary location back to their original location.
    async _revertDeletions(ases) {
        for (const ase of ases.getAllSourceElements()) {
            const parentDir = path.dirname(ase.getMetadataFilePath());
            try {
                await core_1.fs.access(parentDir, core_1.fs.constants.R_OK);
            }
            catch (e) {
                // If the parent directory does not exist, re-create it
                await core_1.fs.mkdirp(parentDir, core_1.fs.DEFAULT_USER_DIR_MODE);
            }
            // Re-create each workspace element
            for (const we of ase.getWorkspaceElements()) {
                const backupPath = path.join(this.tmpBackupDeletions, path.basename(we.getSourcePath()));
                fsExtra.copySync(backupPath, we.getSourcePath());
            }
        }
    }
}
exports.SourceDeployApi = SourceDeployApi;

//# sourceMappingURL=sourceDeployApi.js.map
