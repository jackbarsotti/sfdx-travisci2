"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Node
const util = require("util");
// Local
const MetadataRegistry = require("./metadataRegistry");
const sourceState = require("./sourceState");
const aggregateSourceElement_1 = require("./aggregateSourceElement");
const metadataTypeFactory_1 = require("./metadataTypeFactory");
const forceIgnore_1 = require("./forceIgnore");
const sourceWorkspaceAdapter_1 = require("./sourceWorkspaceAdapter");
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const MaxRevision_1 = require("./MaxRevision");
const packageInfoCache_1 = require("./packageInfoCache");
class SrcStatusApi extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.scratchOrg = options.org;
        this.force = this.scratchOrg.force;
        this.swa = options.adapter;
        this.locallyChangedWorkspaceElements = [];
        this.localChanges = [];
        this.remoteChanges = [];
        this.forceIgnore = new forceIgnore_1.ForceIgnore();
    }
    async init() {
        this.logger = await core_1.Logger.child(this.constructor.name);
        this.maxRevision = await MaxRevision_1.MaxRevision.getInstance({ username: this.scratchOrg.name });
        if (!this.swa) {
            const options = {
                org: this.scratchOrg,
                metadataRegistryImpl: MetadataRegistry,
                defaultPackagePath: this.force.getConfig().getAppConfig().defaultPackagePath
            };
            this.swa = await sourceWorkspaceAdapter_1.SourceWorkspaceAdapter.create(options);
        }
    }
    async doStatus(options) {
        this.populateLocalChanges(options);
        await this.populateServerChanges(options);
        await this.populateRemoteChangesFromFile(options);
        return this.markConflicts(options);
    }
    async populateRemoteChangesFromFile(options) {
        if (!options.remote) {
            return;
        }
        await this.convertSourceMembersToRemoteChanges(await this.maxRevision.retrieveChangedElements());
    }
    populateLocalChanges(options) {
        if (!options.local) {
            return [];
        }
        const localSourceElementsMapByPkg = this.swa.changedSourceElementsCache;
        return localSourceElementsMapByPkg.forEach(localSourceElementsMap => {
            return localSourceElementsMap.forEach(value => {
                value.getWorkspaceElements().forEach(workspaceElement => {
                    value.validateIfDeletedWorkspaceElement(workspaceElement);
                    if (options.local && !options.remote) {
                        this.localChanges.push(workspaceElement.toObject());
                    }
                    else {
                        // if we want to find source conflicts between the workspace and the server,
                        // then pass along the locally changed workspace elements and
                        // populate this.localChanges during the _markConflicts() step
                        this.locallyChangedWorkspaceElements.push(workspaceElement);
                    }
                });
            });
        });
    }
    async populateServerChanges(options) {
        if (!options.remote) {
            return [];
        }
        const maxRevisionNum = this.maxRevision.getServerMaxRevision();
        this.logger.debug(`populateServerChanges maxrevision: ${maxRevisionNum}`);
        const sourceMembers = await this.maxRevision.querySourceMembersFrom(maxRevisionNum);
        await this.convertSourceMembersToRemoteChanges(sourceMembers);
        // filter the sourcemembers from the forceignore and only store the not-ignored ones in maxRevision.json
        sourceMembers.filter(sourceMember => {
            const sourceMemberMetadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(sourceMember.MemberType, this.swa.metadataRegistry);
            if (sourceMemberMetadataType) {
                sourceMember.MemberName = sourceMemberMetadataType.handleSlashesForSourceMemberName(sourceMember.MemberName);
            }
            return this.forceIgnoreSourceMember(sourceMember, sourceMemberMetadataType);
        });
        await this.maxRevision.writeSourceMembers(sourceMembers);
    }
    async convertSourceMembersToRemoteChanges(sourceMembers) {
        let allRemoteChanges = [];
        for (const sourceMember of sourceMembers) {
            const sourceMemberMetadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(sourceMember.MemberType, this.swa.metadataRegistry);
            if (sourceMemberMetadataType) {
                sourceMember.MemberName = sourceMemberMetadataType.handleSlashesForSourceMemberName(sourceMember.MemberName);
            }
            if (!this.forceIgnoreSourceMember(sourceMember, sourceMemberMetadataType)) {
                const els = await this.createRemoteChangeElementsFromSourceMember(sourceMember);
                allRemoteChanges = [...allRemoteChanges, ...els];
            }
        }
        const remoteChanges = allRemoteChanges.reduce((x, y) => x.concat(y), []);
        this.remoteChanges = remoteChanges.filter(sm => !(sm.state === sourceState.DELETED && util.isNullOrUndefined(sm.filePath)));
    }
    forceIgnoreSourceMember(sourceMember, sourceMemberMetadataType) {
        // if user wants to ignore a permissionset with fullname abc then we check if forceignore denies abc.permissionset
        if (sourceMemberMetadataType) {
            const filename = `${sourceMemberMetadataType.getAggregateFullNameFromSourceMemberName(sourceMember.MemberName)}.${sourceMemberMetadataType.getExt()}`;
            if (this.forceIgnore.denies(filename)) {
                return true;
            }
        }
        return false;
    }
    async createRemoteChangeElementsFromSourceMember(sourceMember) {
        const remoteChangeElements = [];
        const sourceMemberMetadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(sourceMember.MemberType, this.swa.metadataRegistry);
        if (sourceMemberMetadataType) {
            if (sourceMemberMetadataType.trackRemoteChangeForSourceMemberName(sourceMember.MemberName)) {
                const correspondingWorkspaceElements = await this.getCorrespondingWorkspaceElements(sourceMember, sourceMemberMetadataType);
                const state = this.getRemoteChangeState(sourceMember, correspondingWorkspaceElements);
                const metadataType = sourceMemberMetadataType.getMetadataName();
                if (this.swa.metadataRegistry.isSupported(metadataType)) {
                    if (!util.isNullOrUndefined(correspondingWorkspaceElements) &&
                        correspondingWorkspaceElements.length > 0 &&
                        !sourceMemberMetadataType.displayAggregateRemoteChangesOnly()) {
                        correspondingWorkspaceElements.forEach(workspaceElement => {
                            const remoteChangeElement = {
                                state,
                                fullName: workspaceElement.getFullName(),
                                type: sourceMemberMetadataType.getDisplayNameForRemoteChange(sourceMember.MemberType),
                                filePath: workspaceElement.getSourcePath(),
                                revisionCounter: sourceMember.RevisionCounter
                            };
                            remoteChangeElements.push(remoteChangeElement);
                        });
                    }
                    else {
                        const remoteChangeElement = {
                            state,
                            fullName: sourceMember.MemberName,
                            type: sourceMemberMetadataType.getDisplayNameForRemoteChange(sourceMember.MemberType),
                            revisionCounter: sourceMember.RevisionCounter
                        };
                        remoteChangeElements.push(remoteChangeElement);
                    }
                }
            }
        }
        return remoteChangeElements;
    }
    getRemoteChangeState(sourceMember, correspondingLocalWorkspaceElements) {
        if (sourceMember.IsNameObsolete) {
            return sourceState.DELETED;
        }
        else if (!util.isNullOrUndefined(correspondingLocalWorkspaceElements) &&
            correspondingLocalWorkspaceElements.length > 0) {
            return sourceState.CHANGED;
        }
        else {
            return sourceState.NEW;
        }
    }
    async getCorrespondingWorkspaceElements(sourceMember, sourceMemberMetadataType) {
        const allLocalAggregateElements = await this.swa.getAggregateSourceElements(false);
        if (!allLocalAggregateElements.isEmpty()) {
            if (sourceMemberMetadataType) {
                const aggregateFullName = sourceMemberMetadataType.getAggregateFullNameFromSourceMemberName(sourceMember.MemberName);
                const aggregateMetadataName = sourceMemberMetadataType.getAggregateMetadataName();
                const key = aggregateSourceElement_1.AggregateSourceElement.getKeyFromMetadataNameAndFullName(aggregateMetadataName, aggregateFullName);
                const fileLocation = this.swa.sourceLocations.getFilePath(aggregateMetadataName, sourceMember.MemberName);
                // if we cannot find an existing fileLocation, it means that the SourceMember has been deleted
                if (!fileLocation) {
                    this.logger.debug(`getCorrespondingWorkspaceElements: Did not find any existing source files for member ${sourceMember.MemberName}. Returning empty array...`);
                    return [];
                }
                const pkgName = packageInfoCache_1.PackageInfoCache.getInstance().getPackageNameFromSourcePath(fileLocation);
                const localAggregateSourceElement = allLocalAggregateElements.getSourceElement(pkgName, key);
                if (!util.isNullOrUndefined(localAggregateSourceElement)) {
                    const workspaceElements = localAggregateSourceElement.getWorkspaceElements();
                    if (workspaceElements.length > 0) {
                        return workspaceElements.filter(workspaceElement => {
                            const workspaceElementMetadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(workspaceElement.getMetadataName(), this.swa.metadataRegistry);
                            return (workspaceElementMetadataType.sourceMemberFullNameCorrespondsWithWorkspaceFullName(sourceMember.MemberName, workspaceElement.getFullName()) ||
                                workspaceElementMetadataType.sourceMemberFullNameCorrespondsWithWorkspaceFullName(`${sourceMember.MemberType}s`, //for nonDecomposedTypesWithChildrenMetadataTypes we need to check their type
                                workspaceElement.getFullName()));
                        });
                    }
                }
            }
        }
        return [];
    }
    markConflicts(options) {
        if (options.local && options.remote) {
            return this.locallyChangedWorkspaceElements.forEach(workspaceElement => {
                // a metadata element with same name and type modified both locally and in the server is considered a conflict
                const localChange = {
                    state: workspaceElement.getState(),
                    fullName: workspaceElement.getFullName(),
                    type: workspaceElement.getMetadataName(),
                    filePath: workspaceElement.getSourcePath(),
                    deleteSupported: workspaceElement.getDeleteSupported()
                };
                const workspaceElementMetadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(workspaceElement.getMetadataName(), this.swa.metadataRegistry);
                const remoteChanges = this.remoteChanges.filter(remoteChange => workspaceElementMetadataType.conflictDetected(remoteChange.type, remoteChange.fullName, workspaceElement.getFullName()));
                if (!util.isNullOrUndefined(remoteChanges) && remoteChanges.length > 0) {
                    localChange.isConflict = true;
                    remoteChanges.forEach(remoteChange => {
                        remoteChange.isConflict = true;
                    });
                }
                this.localChanges.push(localChange);
            });
        }
        else {
            return [];
        }
    }
    getLocalChanges() {
        return this.localChanges;
    }
    getRemoteChanges() {
        return this.remoteChanges;
    }
    getLocalConflicts() {
        const aggregateKeys = new Set();
        return this.localChanges
            .filter(item => {
            const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(item.type, this.swa.metadataRegistry);
            if (item.isConflict && metadataType.onlyDisplayOneConflictPerAggregate()) {
                const aggregateFullName = metadataType.getAggregateFullNameFromWorkspaceFullName(item.fullName);
                const key = `${metadataType.getMetadataName()}#${aggregateFullName}`;
                if (!aggregateKeys.has(key)) {
                    aggregateKeys.add(key);
                    return true;
                }
                return false;
            }
            return item.isConflict;
        })
            .map(item => {
            const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromMetadataName(item.type, this.swa.metadataRegistry);
            if (metadataType.onlyDisplayOneConflictPerAggregate()) {
                return {
                    state: item.state,
                    fullName: metadataType.getAggregateFullNameFromWorkspaceFullName(item.fullName),
                    type: item.type,
                    filePath: metadataType.getDisplayPathForLocalConflict(item.filePath),
                    deleteSupported: item.deleteSupported
                };
            }
            return item;
        });
    }
}
exports.SrcStatusApi = SrcStatusApi;

//# sourceMappingURL=srcStatusApi.js.map
