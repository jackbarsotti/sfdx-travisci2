"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class AggregateSourceElements extends Map {
    constructor(entries) {
        super(entries);
    }
    /**
     * DO NOT USE. Use getSourceElement instead.
     * Returns the FIRST matching AggregateSourceElement. We should not use this method
     * because you're not guaranteed to get the source element from the correct package.
     */
    findSourceElementByKey(key) {
        let returnValue;
        this.forEach(aggregateSourceElements => {
            if (aggregateSourceElements.has(key)) {
                returnValue = aggregateSourceElements.get(key);
            }
        });
        return returnValue;
    }
    getSourceElement(packageName, key) {
        if (this.has(packageName)) {
            return this.get(packageName).get(key);
        }
    }
    deleteSourceElement(packageName, key) {
        if (this.has(packageName)) {
            this.get(packageName).delete(key);
        }
        return this;
    }
    setIn(packageName, sourceElementKey, sourceElement) {
        if (this.has(packageName)) {
            this.get(packageName).set(sourceElementKey, sourceElement);
        }
        else {
            this.set(packageName, new Map().set(sourceElementKey, sourceElement));
        }
        return this;
    }
    /**
     * Returns a flat array of all source elements across all packages
     */
    getAllSourceElements() {
        let elements = [];
        this.forEach(sourceElements => {
            elements = elements.concat([...sourceElements.values()]);
        });
        return elements;
    }
    getAllWorkspaceElements() {
        let elements = [];
        this.forEach(sourceElements => {
            [...sourceElements.values()].forEach(el => {
                elements = elements.concat(el.workspaceElements);
            });
        });
        return elements;
    }
    getAllSourceKeys() {
        let keys = [];
        this.forEach(sourceElements => {
            keys = keys.concat([...sourceElements.keys()]);
        });
        return keys;
    }
    isEmpty() {
        return this.size === 0;
    }
    merge(aggregateSourceElements) {
        aggregateSourceElements.forEach((aseMap, packageName) => {
            if (this.has(packageName)) {
                const elements = this.get(packageName);
                this.set(packageName, new Map([...elements, ...aseMap]));
            }
            else {
                this.set(packageName, aseMap);
            }
        });
        return this;
    }
}
exports.AggregateSourceElements = AggregateSourceElements;

//# sourceMappingURL=aggregateSourceElements.js.map
