import { AnyJson } from '@salesforce/ts-types';
import { AggregateSourceElement } from './aggregateSourceElement';
import { MetadataType } from './metadataType';
import { ManifestEntry, SourceOptions } from './types';
import { SourceWorkspaceAdapter } from './sourceWorkspaceAdapter';
import { AggregateSourceElements } from './aggregateSourceElements';
import MetadataRegistry = require('./metadataRegistry');
import { MaxRevision } from './MaxRevision';
import { SourceMember } from './SourceMember';
/**
 * Validate the value for the 'wait' parameter and reset it as a number.
 * @param flags The command parameters (aka flags)
 * @param minWaitTime The minimum allowable time to wait
 */
export declare const parseWaitParam: (flags: {
    wait?: string;
}, minWaitTime?: number) => void;
/**
 * Validate that the org is a non-source-tracked org.
 * @param orgName The username of the org for doing the source:deploy or source:retrieve
 * @param errAction The action ('push' or 'pull') to take when the org is discovered to be a source tracked org.
 */
export declare const validateNonSourceTrackedOrg: (orgName: string, errAction: string) => Promise<void>;
/**
 * Validate that a manifest file path exists and is readable.
 * @param manifestPath The path to the manifest file (package.xml)
 */
export declare const validateManifestPath: (manifestPath: string) => Promise<void>;
export declare function createOutputDir(cmdName: string): Promise<string>;
export declare function cleanupOutputDir(outputDir: string): Promise<void>;
/**
 * Return the aggregate source element for the specified file
 * @param {string} sourcePath the file in the workspace
 * @param sourceWorkspaceAdapter
 * @returns {AggregateSourceElement}
 */
export declare const getSourceElementForFile: (sourcePath: string, sourceWorkspaceAdapter: SourceWorkspaceAdapter, metadataType?: MetadataType) => Promise<AggregateSourceElement>;
/**
 * Get the source elements from the source path, whether for a particular file or a directory
 */
export declare const getSourceElementsFromSourcePath: (optionsSourcePath: string, sourceWorkspaceAdapter: SourceWorkspaceAdapter) => Promise<AggregateSourceElements>;
/**
 * Return the specified aggregate source element or error if it does not exist
 * @param {AggregateSourceElements} sourceElements All the source elements in the workspace
 * @param {string} key The key of the particular source element we are looking for
 * @param {string} packageName
 * @param {MetadataRegistry} metadataRegistry
 * @returns {AggregateSourceElement}
 */
export declare const loadSourceElement: (sourceElements: AggregateSourceElements, key: string, metadataRegistry: MetadataRegistry, packageName?: string) => AggregateSourceElement;
/**
 * Return the aggregate source elements found in the provided source path
 * @param {Array<string>} sourcePath The path to look for source elements in
 * @param sourceWorkspaceAdapter
 * @returns {AggregateSourceElements}
 */
export declare const getSourceElementsInPath: (sourcePath: string, sourceWorkspaceAdapter: any) => Promise<AggregateSourceElements>;
/**
 * Convert the argument into an array datatype
 * @param arrayOrObjectOrUndefined
 * @returns Array
 */
export declare const toArray: (arrayOrObjectOrUndefined: any) => any[];
/**
 * Parse the manifest file and create a list ManifestEntry objects.
 * @param manifestPath {string} The filepath for the manifest
 * @returns {ManifestEntry[]} An array for ManifestEntry objects from the manifest.
 */
export declare const parseToManifestEntriesArray: (manifestPath: string) => Promise<ManifestEntry[]>;
/**
 * Parse manifest entry strings into an array of ManifestEntry objects
 * @param arg {string} The entry string; e.g., "ApexClass, CustomObject:MyObjectName"
 */
export declare const parseManifestEntries: (entries: string) => ManifestEntry[];
/**
 * Converts SourceOptions.metadata into a package manifest for a given org.
 * @param org { any } The org
 * @param options { SourceOptions } The source options containing the metadata
 * @returns {Promise<string | null>} A path to the created manifest or null of options or options.metadata is null.
 */
export declare const toManifest: (org: any, options: SourceOptions, tmpOutputDir?: string) => Promise<string>;
/**
 * Function to create a manifest for a given org
 * @param org {AnyJson} An org
 * @param options {SourceOptions} Source options
 * @param mdPairs {ManifestEntry[]} Array of metadata items
 * @returns A package.xml manifest
 */
export declare const createManifest: (org: AnyJson, options: SourceOptions, mdPairs?: ManifestEntry[], tmpOutputDir?: string) => Promise<{
    file: string;
}>;
/**
 * Used to determine if an error is the result of parsing bad XML. If so return a new parsing error.
 * @param path The file path.
 * @param error The error to inspect.
 */
export declare const checkForXmlParseError: (path: string, error: Error) => Error;
/**
 * @param options
 */
export declare const containsMdBundle: (options: any) => boolean;
/**
 * sObjects and standard fields aren't returned when polling for SourceMembers, so
 * this will remove sObjects/sFields from the pushResult so that only
 * source tracked metadata types are inserted into the maxRevision.json.
 * @param successes the success of the push or pull result
 * @param {MaxRevision} maxRevision is the class used to query SourceMembers
 * @param pollTimeLimit the number of seconds to poll for SourceMembers before timing out
 * @param fromRevision the RevisionCounter number from which to poll for SourceMembers
 * @returns {Promise<SourceMember[]>}
 */
export declare const getSourceMembersFromResult: (successes: any[], maxRevision: MaxRevision, pollTimeLimit?: number) => Promise<SourceMember[]>;
