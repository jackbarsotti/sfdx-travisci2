import { ForceIgnore } from './forceIgnore';
import { ConfigFile, ConfigContents } from '@salesforce/core';
import { SourcePathInfo } from './sourcePathStatusManager';
import { PackageInfoCache } from './packageInfoCache';
import { AnyJson, Dictionary } from '@salesforce/ts-types';
declare type WorkspacePath = string;
declare type PathInfos = Map<WorkspacePath, SourcePathInfo>;
export declare enum WorkspaceFileState {
    UNCHANGED = "u",
    CHANGED = "c",
    DELETED = "d",
    NEW = "n",
    DUP = "p"
}
export declare type WorkspaceFile = {
    sourcePath: string;
    deferContentHash: boolean;
    isWorkspace: boolean;
    isArtifactRoot: boolean;
    state: WorkspaceFileState;
    package: string;
    isDirectory: boolean;
    isMetadataFile: boolean;
    size: number;
    modifiedTime: number;
    changeTime: number;
    contentHash: string;
};
/**
 * The Workspace class is responsible for traversing the project directory
 * and creating SourcePathInfos for each source path and directory.
 */
export declare namespace Workspace {
    interface Options extends ConfigFile.Options {
        org: any;
        forceIgnore: ForceIgnore;
        isStateless: boolean;
    }
}
export declare class Workspace extends ConfigFile<Workspace.Options> {
    private org;
    private forceIgnore;
    private isStateless;
    private backupPath;
    private logger;
    pathInfos: PathInfos;
    workspacePath: string;
    packageInfoCache: PackageInfoCache;
    trackedPackages: string[];
    constructor(options: Workspace.Options);
    protected init(): Promise<void>;
    private initializeCached;
    private initializeStateFull;
    private initializeStateless;
    getContents(): Dictionary<WorkspaceFile>;
    entries(): [string, WorkspaceFile][];
    getFileName(): string;
    rewriteInfos(): Promise<void>;
    walkDirectories(directories: string[]): Promise<void>;
    /**
     * Walks the directory using native fs.readdir
     */
    walk(directory: string, recur?: boolean): Promise<void>;
    handleArtifact(sourcePath: string, parentDirectory?: string): Promise<SourcePathInfo>;
    /**
     * Check if the given sourcePath should be ignored
     */
    isValidSourcePath(sourcePathInfo: SourcePathInfo): boolean;
    /**
     * Create a new SourcePathInfo from the given sourcePath
     */
    private createSourcePathInfoFromPath;
    write(): Promise<ConfigContents>;
    get(key: string): SourcePathInfo;
    has(key: string): boolean;
    values(): SourcePathInfo[];
    set(key: string, value: SourcePathInfo): ConfigContents;
    protected setMethod(contents: AnyJson, key: string, value: AnyJson): void;
    revert(): Promise<void>;
    backup(): Promise<void>;
    read(): Promise<ConfigContents>;
}
export {};
