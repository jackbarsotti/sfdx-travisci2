"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const sourcePathStatusManager_1 = require("./sourcePathStatusManager");
const packageInfoCache_1 = require("./packageInfoCache");
const path = require("path");
const Messages = require("../messages");
const messages = Messages();
const Package2ConfigFileNames = ['package2-descriptor.json', 'package2-manifest.json'];
// TODO refactor sourceState to the following or remove sourceState in favor of this enum and type.
var WorkspaceFileState;
(function (WorkspaceFileState) {
    WorkspaceFileState["UNCHANGED"] = "u";
    WorkspaceFileState["CHANGED"] = "c";
    WorkspaceFileState["DELETED"] = "d";
    WorkspaceFileState["NEW"] = "n";
    WorkspaceFileState["DUP"] = "p";
})(WorkspaceFileState = exports.WorkspaceFileState || (exports.WorkspaceFileState = {}));
class Workspace extends core_1.ConfigFile {
    constructor(options) {
        super(options);
        this.pathInfos = new Map();
        this.trackedPackages = [];
        this.org = options.org;
        this.forceIgnore = options.forceIgnore;
        this.isStateless = options.isStateless;
        this.workspacePath = options.org.config.getProjectPath();
        this.packageInfoCache = packageInfoCache_1.PackageInfoCache.getInstance();
    }
    async init() {
        this.logger = await core_1.Logger.child(this.constructor.name);
        this.options.filePath = path.join('.sfdx', 'orgs', this.org.name);
        this.options.filename = this.getFileName();
        await super.init();
        this.backupPath = `${this.getPath()}.bak`;
        if (!this.isStateless) {
            await this.initializeCached();
            const pathInfos = this.getContents();
            if (kit_1.isEmpty(pathInfos)) {
                await this.initializeStateFull();
            }
        }
        else {
            await this.initializeStateless();
        }
    }
    async initializeCached() {
        this.logger.debug('Reading workspace from cache');
        let workspacePathChanged;
        const trackedPackages = [];
        try {
            const oldSourcePathInfos = [...this.values()];
            let oldWorkspacePath;
            for (const sourcePathInfoObj of oldSourcePathInfos) {
                if (!sourcePathInfoObj.package) {
                    sourcePathInfoObj.package = this.packageInfoCache.getPackageNameFromSourcePath(sourcePathInfoObj.sourcePath);
                }
                if (sourcePathInfoObj.isWorkspace) {
                    oldWorkspacePath = sourcePathInfoObj.sourcePath;
                }
                if (sourcePathInfoObj.isArtifactRoot) {
                    trackedPackages.push(sourcePathInfoObj.sourcePath);
                }
            }
            this.trackedPackages = trackedPackages;
            workspacePathChanged = !!oldWorkspacePath && this.workspacePath !== oldWorkspacePath;
            for (const sourcePathInfoObj of oldSourcePathInfos) {
                const sourcePathInfo = await sourcePathStatusManager_1.SourcePathInfo.create(sourcePathInfoObj);
                if (workspacePathChanged) {
                    const oldPath = sourcePathInfo.sourcePath;
                    sourcePathInfo.sourcePath = path.join(this.workspacePath, path.relative(oldWorkspacePath, sourcePathInfo.sourcePath));
                    this.unset(oldPath);
                }
                this.set(sourcePathInfo.sourcePath, sourcePathInfo);
            }
        }
        catch (e) {
            // Do nothing if the file can't be read, which will cause the workspace to be initialized
        }
        if (workspacePathChanged) {
            await this.write();
        }
    }
    async initializeStateFull() {
        this.logger.debug('Initializing statefull workspace');
        const packages = this.packageInfoCache.packagePaths.map(p => stripTrailingSlash(p));
        this.trackedPackages = packages;
        await this.walkDirectories(packages);
        await this.write();
    }
    async initializeStateless() {
        this.logger.debug('Initializing stateless workspace');
        this.trackedPackages = this.packageInfoCache.packagePaths.map(p => stripTrailingSlash(p));
        this.setContents({});
    }
    getContents() {
        // override getContents and cast here to avoid casting every getContents() call
        return this['contents'];
    }
    entries() {
        // override entries and cast here to avoid casting every entries() call
        return super.entries();
    }
    getFileName() {
        return 'sourcePathInfos.json';
    }
    async rewriteInfos() {
        await this.initializeStateFull();
    }
    async walkDirectories(directories) {
        for (const directory of directories) {
            const exists = await core_1.fs.fileExists(directory);
            if (!exists) {
                const error = new Error(messages.getMessage('InvalidPackageDirectory', directory));
                error['name'] = 'InvalidProjectWorkspace';
                throw error;
            }
            await this.walk(directory);
        }
    }
    /**
     * Walks the directory using native fs.readdir
     */
    async walk(directory, recur) {
        if (!recur) {
            await this.handleArtifact(directory, directory);
        }
        const files = await core_1.fs.readdir(directory);
        for (let filename of files) {
            const sourcePath = path.join(directory, filename);
            const sourcePathInfo = await this.handleArtifact(sourcePath, directory);
            if (sourcePathInfo.isDirectory) {
                await this.walk(sourcePath, true);
            }
        }
    }
    async handleArtifact(sourcePath, parentDirectory) {
        const isWorkspace = false;
        const isArtifactRoot = parentDirectory ? sourcePath === parentDirectory : false;
        const sourcePathInfo = await this.createSourcePathInfoFromPath(sourcePath, isWorkspace, isArtifactRoot);
        if (this.isValidSourcePath(sourcePathInfo)) {
            this.set(sourcePath, sourcePathInfo);
        }
        return sourcePathInfo;
    }
    /**
     * Check if the given sourcePath should be ignored
     */
    isValidSourcePath(sourcePathInfo) {
        const sourcePath = sourcePathInfo.sourcePath;
        let isValid = this.forceIgnore.accepts(sourcePath);
        const basename = path.basename(sourcePath);
        const isPackage2ConfigFile = Package2ConfigFileNames.includes(basename);
        isValid = !basename.startsWith('.') && !basename.endsWith('.dup') && isValid && !isPackage2ConfigFile;
        if (isValid && !!sourcePathStatusManager_1.SourcePathStatusManager.metadataRegistry) {
            if (!sourcePathInfo.isDirectory) {
                if (!sourcePathStatusManager_1.SourcePathStatusManager.metadataRegistry.isValidSourceFilePath(sourcePath)) {
                    const error = new Error(`Unexpected file found in package directory: ${sourcePath}`);
                    error['name'] = 'UnexpectedFileFound';
                    throw error;
                }
            }
        }
        // Skip directories/files beginning with '.', end with .dup, and that should be ignored
        return isValid;
    }
    /**
     * Create a new SourcePathInfo from the given sourcePath
     */
    async createSourcePathInfoFromPath(sourcePath, isWorkspace, isArtifactRoot) {
        return sourcePathStatusManager_1.SourcePathInfo.create({
            sourcePath,
            deferContentHash: false,
            isWorkspace,
            isArtifactRoot
        });
    }
    async write() {
        if (!this.has(this.workspacePath)) {
            const workspaceSourcePathInfo = await this.createSourcePathInfoFromPath(this.workspacePath, true, false);
            this.set(this.workspacePath, workspaceSourcePathInfo);
        }
        return super.write();
    }
    // @ts-ignore
    get(key) {
        return this.getContents()[key];
    }
    has(key) {
        return !!this.get(key);
    }
    // @ts-ignore
    values() {
        return super.values();
    }
    // @ts-ignore
    set(key, value) {
        return super.set(key, value);
    }
    setMethod(contents, key, value) {
        contents[key] = value;
    }
    async revert() {
        if (await core_1.fs.fileExists(this.backupPath)) {
            const backedupContents = await core_1.fs.readFile(this.backupPath, 'UTF-8');
            this.setContentsFromObject(JSON.parse(backedupContents));
            await this.write();
            await core_1.fs.unlink(this.backupPath);
        }
    }
    async backup() {
        if (this.exists()) {
            await core_1.fs.writeFile(this.backupPath, JSON.stringify(this.getContents()));
        }
    }
    async read() {
        try {
            return await super.read();
        }
        catch (err) {
            if (err.name === 'JsonDataFormatError') {
                // This error means that the old sourcePathInfos format is still
                // in use and so we need to convert it to the new format.
                const contents = await core_1.fs.readFile(this.getPath(), 'utf-8');
                const map = new Map(JSON.parse(contents));
                const obj = {};
                map.forEach((value, key) => (obj[key] = value));
                this.setContentsFromObject(obj);
                await this.write();
                return this.getContents();
            }
        }
    }
}
exports.Workspace = Workspace;
function stripTrailingSlash(str) {
    return str.endsWith('/') ? str.slice(0, -1) : str;
}

//# sourceMappingURL=workspace.js.map
