"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, Salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
const srcDevUtil = require('../../core/srcDevUtil');
const forceIgnore_1 = require("../forceIgnore");
const nonDecomposedContentStrategy_1 = require("./nonDecomposedContentStrategy");
const experienceBundleMetadataType_1 = require("../metadataTypeImpl/experienceBundleMetadataType");
/**
 * Works on top of NonDecomposedContentStrategy with special logic to handle delete
 */
class ExperienceBundleContentStrategy extends nonDecomposedContentStrategy_1.NonDecomposedContentStrategy {
    constructor(metadataType, metadataRegistry, workspaceVersion) {
        super(metadataType, metadataRegistry, workspaceVersion);
        this.forceIgnore = new forceIgnore_1.ForceIgnore();
    }
    /**
     * If there is a file in existing path and if it didn't get returned in the MD-retrieve, then we assume it is deleted
     * Since, we need a list of all files from retrieve to compare we cannot use MetadataType#getWorkspaceElementsToDelete()
     */
    saveContent(metadataFilePath, retrievedContentFilePaths, retrievedMetadataFilePath, createDuplicates, unsupportedMimeTypes, forceoverwrite = false) {
        const existingFiles = experienceBundleMetadataType_1.ExperienceBundleMetadataType.getContentFilePaths(metadataFilePath, this.forceIgnore);
        var [newPaths, updatedPaths, deletedPaths, dupPaths] = super.saveContent(metadataFilePath, retrievedContentFilePaths, retrievedMetadataFilePath, createDuplicates, unsupportedMimeTypes, forceoverwrite);
        const relativeRetrievedPaths = retrievedContentFilePaths.map(path => this.metadataType.getRelativeContentPath(path));
        existingFiles.forEach(path => {
            const relativePath = this.metadataType.getRelativeContentPath(path);
            if (!relativeRetrievedPaths.includes(relativePath)) {
                srcDevUtil.deleteIfExistsSync(path);
                deletedPaths.push(path);
            }
        });
        return [newPaths, updatedPaths, deletedPaths, dupPaths];
    }
}
exports.ExperienceBundleContentStrategy = ExperienceBundleContentStrategy;

//# sourceMappingURL=experienceBundleContentStrategy.js.map
