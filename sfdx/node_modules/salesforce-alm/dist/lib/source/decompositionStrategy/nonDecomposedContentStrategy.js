"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const MetadataRegistry = require("../metadataRegistry");
const srcDevUtil = require("../../core/srcDevUtil");
const metadataTypeFactory_1 = require("../metadataTypeFactory");
/**
 *  Content strategy for content files that do not require decomposition e.g. ApexClass
 */
class NonDecomposedContentStrategy {
    constructor(metadataType, metadataRegistry, workspaceVersion) {
        this.metadataType = metadataType;
        this.metadataRegistry = metadataRegistry;
    }
    getContentPaths(metadataFilePath) {
        const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromSourcePath(metadataFilePath, this.metadataRegistry);
        const aggregateFullName = metadataType.getAggregateFullNameFromFilePath(metadataFilePath);
        const workspaceDir = path.dirname(metadataFilePath);
        const directoryItems = srcDevUtil.getDirectoryItems(workspaceDir, true, true);
        return directoryItems.filter(directoryItem => {
            const itemFullName = metadataType.getAggregateFullNameFromFilePath(directoryItem);
            return (!directoryItem.startsWith('.') &&
                !directoryItem.endsWith(MetadataRegistry.getMetadataFileExt()) &&
                aggregateFullName === itemFullName);
        });
    }
    saveContent(metadataFilePath, retrievedContentFilePaths, retrievedMetadataFilePath, createDuplicates, unsupportedMimeTypes, forceoverwrite = false) {
        const newPaths = [];
        const updatedPaths = [];
        const deletedPaths = [];
        const dupPaths = [];
        const metadataType = metadataTypeFactory_1.MetadataTypeFactory.getMetadataTypeFromSourcePath(metadataFilePath, this.metadataRegistry);
        retrievedContentFilePaths.forEach(retrievedContentFilePath => {
            const workspaceContentFilePath = metadataType.getWorkspaceContentFilePath(metadataFilePath, retrievedContentFilePath);
            if (srcDevUtil.pathExistsSync(workspaceContentFilePath)) {
                if (forceoverwrite ||
                    !NonDecomposedContentStrategy.filesAreEqual(retrievedContentFilePath, workspaceContentFilePath)) {
                    if (createDuplicates) {
                        const dupPath = workspaceContentFilePath + '.dup';
                        fs.copySync(retrievedContentFilePath, dupPath);
                        dupPaths.push(dupPath);
                    }
                    else {
                        fs.copySync(retrievedContentFilePath, workspaceContentFilePath);
                        updatedPaths.push(workspaceContentFilePath);
                    }
                }
            }
            else {
                fs.copySync(retrievedContentFilePath, workspaceContentFilePath);
                newPaths.push(workspaceContentFilePath);
            }
        });
        return [newPaths, updatedPaths, deletedPaths, dupPaths];
    }
    static filesAreEqual(filePathA, filePathB) {
        const contentA = fs.readFileSync(filePathA);
        const contentB = fs.readFileSync(filePathB);
        const contentHashA = srcDevUtil.getContentHash(contentA);
        const contentHashB = srcDevUtil.getContentHash(contentB);
        return contentHashA === contentHashB;
    }
}
exports.NonDecomposedContentStrategy = NonDecomposedContentStrategy;

//# sourceMappingURL=nonDecomposedContentStrategy.js.map
