"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@salesforce/core");
const sourceRetrieve_1 = require("./sourceRetrieve");
const sourceUtil_1 = require("./sourceUtil");
const syncCommandHelper = require("./syncCommandHelper");
const logApi = require("../core/logApi");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('salesforce-alm', 'source_retrieve');
// One of these flags must be specified for a valid retrieve.
const requiredFlags = ['manifest', 'metadata', 'sourcepath', 'packagenames'];
/**
 * Command for retrieving metadata from a non-source-tracked org and updating a local SFDX project.
 */
class SourceRetrieveCommand {
    constructor() {
        this.logger = logApi.child('source:retrieve');
    }
    /**
     * Executes the source retrieve command
     * @param context - the cli context
     * @returns {Promise}
     */
    async execute(context) {
        return await new sourceRetrieve_1.SourceRetrieve(context.org).retrieve(context.flags);
    }
    /**
     * Validates the source retrieve command parameters
     * @param context - the cli context
     * @returns {Promise}
     */
    async validate(context) {
        // Validate the wait param if set and convert to an integer.
        sourceUtil_1.parseWaitParam(context.flags);
        // verify that the user defined one of: manifest, metadata, sourcepath, packagenames
        if (!Object.keys(context.flags).some(flag => requiredFlags.includes(flag))) {
            throw core_1.SfdxError.create('salesforce-alm', 'source', 'MissingRequiredParam', requiredFlags);
        }
        // verify that the manifest file exists and is readable.
        if (context.flags.manifest) {
            await sourceUtil_1.validateManifestPath(context.flags.manifest);
        }
        return Promise.resolve(context);
    }
    getHumanSuccessMessage(results) {
        const commonMsgs = core_1.Messages.loadMessages('salesforce-alm', 'source');
        // Display any package retrievals
        if (results.packages && results.packages.length) {
            this.logger.styledHeader(this.logger.color.blue('Retrieved Packages'));
            results.packages.forEach(pkg => {
                this.logger.log(`${pkg.name} package converted and retrieved to: ${pkg.path}`);
            });
            this.logger.log('');
        }
        this.logger.styledHeader(this.logger.color.blue(messages.getMessage('retrievedSourceHeader')));
        if (results.inboundFiles && results.inboundFiles.length) {
            const columns = syncCommandHelper.getColumnMetaInfo(commonMsgs, true);
            this.logger.table(results.inboundFiles, { columns });
        }
        else {
            this.logger.log(messages.getMessage('NoResultsFound'));
        }
        if (results.warnings) {
            this.logger.log('');
            this.logger.styledHeader(this.logger.color.yellow(messages.getMessage('metadataNotFoundWarning')));
            results.warnings.forEach(warning => this.logger.log(warning.problem));
        }
    }
}
exports.SourceRetrieveCommand = SourceRetrieveCommand;

//# sourceMappingURL=sourceRetrieveCommand.js.map
