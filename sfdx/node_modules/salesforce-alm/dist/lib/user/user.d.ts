import { ReadablePermissionSet } from './permissionSetAssignment';
declare class User {
    private org;
    private force;
    private logger;
    private _refreshToken;
    private _fields;
    private _permissionSetAssignments;
    private _password;
    static readonly REQUIRED_FIELDS: string[];
    static readonly isValidPassword: RegExp;
    constructor(org: any);
    get id(): string;
    get isCreated(): boolean;
    get refreshToken(): string;
    get permissionSetAssignments(): ReadablePermissionSet[];
    get password(): string;
    get fields(): any;
    getField(key: string): string;
    setFields(fields?: object): User;
    create(fields?: object): Promise<User>;
    retrieve(userId: string): Promise<this>;
    update(fields?: object): Promise<User>;
    assignPermissionSets(permsetNames: string[]): Promise<User>;
    /**
     * Set the password for this user and update the auth file.
     * @param {string} password - The new password.  Leave unassigned to generate a password.
     * @returns {Promise.<User>}
     */
    assignPassword(password?: string): Promise<User>;
    /**
     * Generate a password that can be used with User.assignPassword.
     * @returns {String} - the generated password
     */
    static generatePassword(): string;
    /**
     * Queries an org for fields of the provided usernames, then creates and returns User objects.
     *
     * @param {Org} org - the org where the users exist
     * @param {string[]} usernames - array of usernames to fetch
     * @param {string[]} fields - array of fields that should be returned by the query.  defaults to ['Id', 'Username'].
     * @returns {Promise.<User[]>} a Promise of an array of User objects.
     */
    static fetchUsers(org: any, usernames: string[], fields?: string[]): Promise<User[]>;
    toJSON(): any;
}
export default User;
