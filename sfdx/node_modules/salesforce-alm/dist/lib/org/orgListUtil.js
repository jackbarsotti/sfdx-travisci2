"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BBPromise = require("bluebird");
const _ = require("lodash");
const moment = require("moment");
const core_1 = require("@salesforce/core");
const path_1 = require("path");
const Alias = require("../core/alias");
const fs_1 = require("fs");
class OrgListUtil {
    static async retrieveLogger() {
        if (!OrgListUtil.logger) {
            OrgListUtil.logger = await core_1.Logger.child('OrgListUtil');
        }
        return OrgListUtil.logger;
    }
    /**
     * This method takes all locally configured orgs and organizes them into the following buckets:
     * { activeScratchOrgs: [{}], nonScratchOrgs: [{}], scratchOrgs: [{}] }
     * the scratchOrgInfo query.
     * @param {string[]|null} excludeProperties - properties to exclude from the configs defaults. ['refreshToken', 'clientSecret']. Specify null to include all properties.
     * @param {string[]|null} userFilenames- an array of strings that are validated against the server.
     */
    static async readLocallyValidatedMetaConfigsGroupedByOrgType(userFilenames, flags, excludeProperties) {
        const contents = await this.readAuthFiles(userFilenames);
        const authInfos = contents.reduce((map, content) => {
            if (content) {
                map[content.getUsername()] = content;
            }
            return map;
        }, {});
        const orgs = await this._groupOrgs(contents, this._accum, excludeProperties);
        /** Retrieve scratch org info for scratch orgs that do not have exp date in their auth files */
        await Promise.all(orgs.queryExpirationDate.map(async (fields) => {
            if (fields.devHubUsername) {
                try {
                    const devHugOrg = await core_1.Org.create({ aliasOrUsername: fields.devHubUsername });
                    const authInfo = authInfos[fields.username];
                    if (authInfo) {
                        await this.retrieveScratchOrgExpDate(devHugOrg, core_1.sfdc.trimTo15(fields.orgId), authInfo);
                    }
                }
                catch (err) {
                    // Throwing an error will cause the comand to exit with the error. We just want the exp date information of all orgs.
                }
            }
        }));
        const allScratchOrgs = orgs.activeScratchOrgs.concat(orgs.expiredScratchOrgs);
        orgs.totalScratchOrgs = allScratchOrgs;
        /** Ensure addtional fields have been added to the scratchOrg info */
        if (flags.verbose || flags.json) {
            let orgIdsToQuery = {};
            const orgsToQuery = flags.all ? orgs.totalScratchOrgs : orgs.activeScratchOrgs;
            orgsToQuery.forEach(fields => {
                if (fields.devHubUsername) {
                    if (!orgIdsToQuery[fields.devHubUsername]) {
                        orgIdsToQuery[fields.devHubUsername] = [];
                    }
                    orgIdsToQuery[fields.devHubUsername].push(core_1.sfdc.trimTo15(fields.orgId));
                }
            });
            let updatedContents = (await Promise.all(Object.entries(orgIdsToQuery).map(async ([username, orgIds]) => {
                const data = await this.retrieveScratchOrgInfoFromDevHub(username, orgIds);
                return data;
            }))).reduce((list, contents) => [...list, ...contents], []);
            const resultOrgInfo = await this.reduceScratchOrgInfo(updatedContents, orgsToQuery);
            if (flags.all) {
                orgs.totalScratchOrgs = resultOrgInfo;
            }
            else {
                orgs.activeScratchOrgs = resultOrgInfo;
            }
        }
        if (flags.skipconnectionstatus) {
            return orgs;
        }
        else {
            await BBPromise.map(orgs.nonScratchOrgs, (fields) => {
                // attempt to get the connection status of the devhub
                return this.determineDevHubConnStatus(fields);
            });
            return orgs;
        }
    }
    /**
     * Used to retrieve authInfo of the auth files
     * @param fileNames All the filenames in the global hidden folder
     */
    static async readAuthFiles(fileNames) {
        const allAuths = await Promise.all(fileNames.map(async (fileName) => {
            try {
                let orgUsername = path_1.basename(fileName, '.json');
                return core_1.AuthInfo.create({ username: orgUsername });
            }
            catch (err) {
                const logger = await OrgListUtil.retrieveLogger();
                logger.warn(`Problem reading file: ${fileName} skipping`);
                logger.warn(err.message);
            }
        }));
        return allAuths.filter(authInfo => !!authInfo);
    }
    /**
     * retrieves the connection info of an nonscratch org
     * @returns {BBPromise.<array>}
     */
    static async determineDevHubConnStatus(fields) {
        try {
            const org = await core_1.Org.create({ aliasOrUsername: fields.username });
            // Do the query for orgs without a devHubUsername attribute. In some cases scratch org auth
            // files may not have a devHubUsername property; but that's ok. We will discover it before this.
            const devHubUsername = org.getField(core_1.Org.Fields.DEV_HUB_USERNAME);
            if (!devHubUsername) {
                try {
                    await org.refreshAuth();
                    fields.connectedStatus = 'Connected';
                }
                catch (error) {
                    const logger = await OrgListUtil.retrieveLogger();
                    logger.trace(`error refreshing auth for org: ${org.getUsername()}`);
                    logger.trace(error);
                    fields.connectedStatus = error['code'] || error.message;
                }
            }
            // Don't do anything if it isn't devhub
        }
        catch (e) {
            fields.connectedStatus = 'Unknown';
        }
    }
    /**
     * Helper to group orgs by {activeScratchOrgs, scratchOrg, nonScratchOrgs}
     * @param {object} contents -The authinfo retrieved from the auth files
     * @param {string[]} excludeProperties - properties to exclude from the grouped configs ex. ['refreshToken', 'clientSecret']
     * @private
     */
    static async _groupOrgs(authInfos, _accum, excludeProperties) {
        const config = (await core_1.ConfigAggregator.create()).getConfig();
        for (const authInfo of authInfos) {
            const fields = authInfo.getFields();
            const currentValue = OrgListUtil._removeRestrictedInfoFromConfig(fields, excludeProperties);
            currentValue.alias = await Alias.byValue(fields.username);
            currentValue.lastUsed = fs_1.statSync(path_1.join(core_1.Global.DIR, `${fields.username}.json`)).atime;
            this.identifyDefaultOrgs(currentValue, config);
            if (currentValue.devHubUsername) {
                if (!currentValue.expirationDate) {
                    _accum['queryExpirationDate'].push(currentValue);
                }
                else if (OrgListUtil._identifyActiveOrgs(currentValue.expirationDate)) {
                    currentValue.status = 'Active';
                    currentValue.isExpired = false;
                    _accum['activeScratchOrgs'].push(currentValue);
                }
                else {
                    currentValue.status = 'Expired';
                    currentValue.isExpired = true;
                    _accum['expiredScratchOrgs'].push(currentValue);
                }
            }
            else {
                _accum['nonScratchOrgs'].push(currentValue);
            }
        }
        return _accum;
    }
    static async retrieveScratchOrgExpDate(devHub, orgId, authInfo) {
        const _fields = ['ExpirationDate'];
        const conn = devHub.getConnection();
        const object = await conn.sobject('ScratchOrgInfo').find({ ScratchOrg: orgId }, _fields);
        if (object.length > 0) {
            // There should only be one.
            await this.writeFieldsToAuthFile(object[0], authInfo);
        }
    }
    static async writeFieldsToAuthFile(scratchOrgInfo, authInfo, excludeProperties) {
        let authInfoFields = authInfo.getFields();
        if (!authInfoFields['ExpirationDate']) {
            await authInfo.save({ expirationDate: scratchOrgInfo.ExpirationDate });
            authInfoFields = OrgListUtil._removeRestrictedInfoFromConfig(authInfoFields, excludeProperties);
            authInfoFields.alias = await Alias.byValue(authInfoFields.username);
            authInfoFields.lastUsed = fs_1.statSync(path_1.join(core_1.Global.DIR, `${authInfoFields.username}.json`)).atime;
            if (this._identifyActiveOrgs(authInfoFields.expirationDate)) {
                authInfoFields['status'] = 'Active';
                authInfoFields.isExpired = false;
                this._accum.activeScratchOrgs.push(authInfoFields);
            }
            else {
                authInfoFields['status'] = 'Expired';
                authInfoFields.isExpired = true;
                this._accum.expiredScratchOrgs.push(authInfoFields);
            }
        }
    }
    /**
     * Helper utility to remove sensitive information from a scratch org auth config. By default refreshTokens and client secrets are removed.
     * @param {*} config - scratch org auth object.
     * @param {string[]} properties - properties to exclude ex ['refreshToken', 'clientSecret']
     * @returns the config less the sensitive information.
     */
    static _removeRestrictedInfoFromConfig(config, properties = ['refreshToken', 'clientSecret']) {
        return _.omit(config, properties);
    }
    /**
     * Helper to identify active orgs based on the expiration data.
     * @param expirationDate
     */
    static _identifyActiveOrgs(expirationDate) {
        return moment(expirationDate).isAfter(moment());
    }
    /**Identify the default orgs */
    static identifyDefaultOrgs(orgInfo, config) {
        const defaultUsername = config.defaultusername;
        const defaultDevhubUsername = config.defaultdevhubusername;
        if (orgInfo.username === defaultUsername || orgInfo.alias === defaultUsername) {
            orgInfo.isDefaultUsername = true;
        }
        else if (orgInfo.username === defaultDevhubUsername || orgInfo.alias === defaultDevhubUsername) {
            orgInfo.isDefaultDevHubUsername = true;
        }
    }
    static async retrieveScratchOrgInfoFromDevHub(username, orgIdsToQuery) {
        const _fields = ['OrgName', 'CreatedBy.Username', 'CreatedDate', 'Edition', 'SignupUsername'];
        try {
            const devHubOrg = await core_1.Org.create({ aliasOrUsername: username });
            const conn = devHubOrg.getConnection();
            const data = await conn
                .sobject('ScratchOrgInfo')
                .find({ ScratchOrg: { $in: orgIdsToQuery } }, _fields);
            data.map(org => {
                org.devHubOrgId = devHubOrg.getOrgId();
                /** For orgs that are not dev hubs, we need not return a connectedStatus */
                org.connectedStatus = 'Unknown';
                return org;
            });
            return data;
        }
        catch (err) {
            return [];
        }
    }
    static async reduceScratchOrgInfo(updatedContents, orgs) {
        /** Reduce the information to key value pairs with signupUsername as key */
        const contentMap = updatedContents.reduce((map, scratchOrgInfo) => {
            if (!!scratchOrgInfo) {
                map[scratchOrgInfo.SignupUsername] = scratchOrgInfo;
            }
            return map;
        }, {});
        for (const scratchOrgInfo of orgs) {
            const updatedOrgInfo = contentMap[scratchOrgInfo.username];
            if (updatedOrgInfo) {
                scratchOrgInfo.signupUsername = updatedOrgInfo.SignupUsername;
                scratchOrgInfo.createdBy = updatedOrgInfo.CreatedBy.Username;
                scratchOrgInfo.createdDate = updatedOrgInfo.CreatedDate;
                scratchOrgInfo.devHubOrgId = updatedOrgInfo.devHubOrgId;
                scratchOrgInfo.attributes = updatedOrgInfo.attributes;
                scratchOrgInfo.orgName = updatedOrgInfo.OrgName;
                scratchOrgInfo.edition = updatedOrgInfo.Edition;
                scratchOrgInfo.connectedStatus = updatedOrgInfo.connectedStatus;
            }
            else {
                const logger = await OrgListUtil.retrieveLogger();
                logger.warn(`Can't find ${scratchOrgInfo.username} in the updated contents`);
            }
        }
        return orgs;
    }
}
exports.OrgListUtil = OrgListUtil;
OrgListUtil._accum = {
    nonScratchOrgs: [],
    activeScratchOrgs: [],
    expiredScratchOrgs: [],
    queryExpirationDate: [],
    totalScratchOrgs: []
};

//# sourceMappingURL=orgListUtil.js.map
