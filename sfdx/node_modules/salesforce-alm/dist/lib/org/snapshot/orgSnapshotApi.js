"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("util");
const moment = require("moment");
const Messages = require("../../messages");
const messages = Messages();
exports.ORG_SNAPSHOT_FIELDS = [
    'Id',
    'SnapshotName',
    'Description',
    'Status',
    'SourceOrg',
    'CreatedDate',
    'LastModifiedDate',
    'ExpirationDate',
    'LastClonedDate',
    'LastClonedById',
    'Error'
];
const DATETIME_FORMAT = 'YYYY-MM-DD HH:mm:ss';
const DATE_FORMAT = 'YYYY-MM-DD';
exports.ORG_SNAPSHOT_COLUMNS = [
    { key: 'Id', label: 'Id' },
    { key: 'SnapshotName', label: 'SnapshotName' },
    { key: 'Status', label: 'Status' },
    { key: 'SourceOrg', label: 'Source Org Id' },
    {
        key: 'CreatedDate',
        label: 'Created Date',
        format: value => (value ? moment(value).format(DATETIME_FORMAT) : '')
    },
    {
        key: 'LastModifiedDate',
        label: 'Last Modified Date',
        format: value => (value ? moment(value).format(DATETIME_FORMAT) : '')
    },
    {
        key: 'ExpirationDate',
        label: 'Expiration Date',
        format: value => (value ? moment(value).format(DATE_FORMAT) : '')
    },
    {
        key: 'LastClonedDate',
        label: 'Last Cloned Date',
        format: value => (value ? moment(value).format(DATETIME_FORMAT) : '')
    },
    { key: 'LastClonedById', label: 'Last Cloned By Id' }
];
const LIST_QUERY = `SELECT ${exports.ORG_SNAPSHOT_FIELDS.join(',')} FROM OrgSnapshot ORDER BY CreatedDate`;
const GET_QUERY_BY_ID = `SELECT ${exports.ORG_SNAPSHOT_FIELDS.join(',')} FROM OrgSnapshot WHERE Id=\'%s\'`;
const GET_QUERY_BY_NAME = `SELECT ${exports.ORG_SNAPSHOT_FIELDS.join(',')} FROM OrgSnapshot WHERE SnapshotName LIKE \'%s\'`;
exports.PERM_QUERY = 'SELECT Id FROM OrgSnapshot LIMIT 1';
const CONTENT = 'metadatadata';
const ORG_SNAPSHOT = 'OrgSnapshot';
const ORG_SNAPSHOT_KEY_PREFIX = '0Oo';
const ORG_SNAPSHOT_NOT_SUPPORTED = `'${ORG_SNAPSHOT}' is not supported`;
/**
 * Org Snapshot API Implementation.
 */
class OrgSnapshotApiImpl {
    // use create()
    constructor(org) {
        this.devHubOrg = org;
        this.force = org.force;
    }
    static async create(org) {
        const api = new OrgSnapshotApiImpl(org);
        await api.checkOrgSnapshotPerm();
        return api;
    }
    /**
     * Create OrgSnapshot record and org export.
     *
     * @param {OrgSnapshotRequest} request
     * @returns {Promise<OrgSnapshot>}
     */
    async create(request) {
        request.Content = request.Content || CONTENT;
        let createResult;
        try {
            createResult = await this.force.create(this.devHubOrg, ORG_SNAPSHOT, request);
        }
        catch (err) {
            this.checkForNotSupported(err);
        }
        if (!createResult.success) {
            throw new Error(createResult.errors);
        }
        // retrieve to show status
        return this.get(createResult.id);
    }
    /**
     * Delete OrgSnapshot record and underlying export.
     *
     * @param {string} orgSnapshotIdOrName
     * @returns {Promise<OrgSnapshot>}
     */
    async delete(orgSnapshotIdOrName) {
        const orgSnapshotId = await this.getOrgSnapshotId(orgSnapshotIdOrName);
        let deleteResult;
        try {
            deleteResult = await this.force.delete(this.devHubOrg, ORG_SNAPSHOT, orgSnapshotId);
        }
        catch (err) {
            this.checkForNotSupported(err);
        }
        if (!deleteResult.success) {
            const errors = deleteResult.errors && deleteResult.errors.length > 0 ? deleteResult.errors.join(', ') : 'Unknown error';
            throw Error(`Unable to delete ${ORG_SNAPSHOT} with name '${orgSnapshotIdOrName}': ${errors}`);
        }
        return deleteResult;
    }
    /**
     * Get OrgSnapshot by given ID or name.
     *
     * @param {string} orgSnapshotIdOrName
     * @returns {Promise<OrgSnapshot>}
     */
    async get(orgSnapshotIdOrName) {
        const query = orgSnapshotIdOrName.startsWith(ORG_SNAPSHOT_KEY_PREFIX) ? GET_QUERY_BY_ID : GET_QUERY_BY_NAME;
        let queryResult;
        try {
            queryResult = await this.force.query(this.devHubOrg, util.format(query, orgSnapshotIdOrName));
        }
        catch (err) {
            this.checkForNotSupported(err);
        }
        if (!queryResult.records || !queryResult.records[0]) {
            throw Error(`${ORG_SNAPSHOT} with ID or name '${orgSnapshotIdOrName}' not found`);
        }
        return queryResult.records[0];
    }
    /**
     * Get OrgSnapshot records.
     *
     * @returns {Promise<OrgSnapshot[]>}
     */
    async list() {
        try {
            const queryResult = await this.force.query(this.devHubOrg, LIST_QUERY);
            return queryResult.records ? queryResult.records : [];
        }
        catch (err) {
            this.checkForNotSupported(err);
        }
    }
    /**
     * Returns name-value pairs of column to data
     * @param result
     * @returns {ColumnData[]}
     */
    mapDataToLabel(result) {
        return [
            { name: 'Id', value: result.Id },
            { name: 'Snapshot Name', value: result.SnapshotName },
            { name: 'Description', value: result.Description },
            { name: 'Status', value: result.Status },
            { name: 'Source Org', value: result.SourceOrg },
            {
                name: 'Expiration Date',
                value: result.ExpirationDate ? moment(result.ExpirationDate).format(DATE_FORMAT) : ''
            },
            {
                name: 'Last Cloned Date',
                value: result.LastClonedDate ? moment(result.LastClonedDate).format(DATETIME_FORMAT) : ''
            },
            { name: 'Last Cloned By', value: result.LastClonedById },
            {
                name: 'Created Date',
                value: moment(result.CreatedDate).format(DATETIME_FORMAT)
            },
            {
                name: 'Last Modified Date',
                value: moment(result.LastModifiedDate).format(DATETIME_FORMAT)
            }
        ];
    }
    async getOrgSnapshotId(orgSnapshotIdOrName) {
        if (orgSnapshotIdOrName.startsWith(ORG_SNAPSHOT_KEY_PREFIX)) {
            return orgSnapshotIdOrName;
        }
        else {
            // retrieve ID
            const record = await this.get(orgSnapshotIdOrName);
            return record.Id;
        }
    }
    async checkOrgSnapshotPerm() {
        try {
            await this.force.query(this.devHubOrg, exports.PERM_QUERY);
        }
        catch (err) {
            this.checkForNotSupported(err);
        }
        return Promise.resolve(null);
    }
    // inspects if error is lack of OrgSnapshot perm
    checkForNotSupported(err) {
        if (err.message && err.message.includes(ORG_SNAPSHOT_NOT_SUPPORTED)) {
            throw new Error(messages.getMessage('snapshotNotEnabled', [], 'orgSnapshot'));
        }
        else {
            throw err;
        }
    }
}
exports.OrgSnapshotApiImpl = OrgSnapshotApiImpl;

//# sourceMappingURL=orgSnapshotApi.js.map
