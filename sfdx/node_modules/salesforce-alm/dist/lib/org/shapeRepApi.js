"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const optional = require("optional-js");
const _ = require("lodash");
const Force = require("../core/force"); // eslint-disable-line global-require
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('salesforce-alm', 'org_shape');
/**
 * Shape API object, for all of your ShapeRepresentation needs
 * @constructor
 * @param forceApi The force api
 * @param shapeOrg The org we'll be querying against
 */
class ShapeRepresentationApi {
    constructor(forceApi, shapeOrg) {
        this.force = optional.ofNullable(forceApi).orElse(new Force());
        this.shapeOrg = shapeOrg;
    }
    async create(description = '') {
        return this.force
            .create(this.shapeOrg, 'ShapeRepresentation', {
            Description: description
        })
            .catch(err => {
            return Promise.reject(err);
        });
    }
    /**
     * Delete all ShapeRepresentation records for the shapeOrg.
     * @return List of SR IDs that were deleted
     */
    async deleteAll() {
        let shapeIds = [];
        try {
            const result = await this.force.query(this.shapeOrg, 'SELECT Id FROM ShapeRepresentation');
            shapeIds = result.records.map(shape => {
                return shape.Id;
            });
        }
        catch (err) {
            if (err.errorCode && err.errorCode === 'INVALID_TYPE') {
                // ShapeExportPref is not enabled, or user does not have CRUD access
                return Promise.reject(new core_1.SfdxError(messages.getMessage('delete_shape_command_no_access', shapeIds)));
            }
            // non-access error
            return Promise.reject(err);
        }
        return Promise.all(shapeIds.map(async (id) => {
            try {
                const delResult = await this.force.delete(this.shapeOrg, 'ShapeRepresentation', id);
                if (delResult.success) {
                    return delResult.id;
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        }));
    }
    /**
     * Find all ShapeRepresentation records with a state of Active or InProgress.
     * @return SOQL response or null
     */
    async findShapesOrNull() {
        const query = "SELECT Id, Status, CreatedBy.Username, CreatedDate FROM ShapeRepresentation WHERE Status IN ( 'Active', 'InProgress' )";
        return this.force.query(this.shapeOrg, query).catch(err => {
            if (err.errorCode && err.errorCode === 'INVALID_TYPE') {
                // ShapeExportPref is not enabled
                return Promise.resolve();
            }
            // some important error
            return Promise.reject(err);
        });
    }
    /**
     * Check if the ShapeExportPilot preference is enabled.
     */
    async isFeatureEnabled() {
        const aggregator = await core_1.ConfigAggregator.create();
        if (aggregator.getInfo('apiVersion').value < 48) {
            return this.isFeatureEnabledBefore48();
        }
        else {
            return this.isFeatureEnabledAfter48();
        }
    }
    async isFeatureEnabledBefore48() {
        const prefValue = this.force.toolingQuery(this.shapeOrg, `SELECT SettingValue FROM ${'OrganizationSettingsDetail'} WHERE SettingName = 'ShapeExportPref'`);
        // no records are returned if ShapeExportPilot perm is disabled
        return prefValue.then(value => {
            const hasResults = _.get(value, 'totalSize', 0) > 0;
            const enabled = hasResults && _.get(value, 'records[0].SettingValue', false);
            return Promise.resolve(enabled);
        });
    }
    async isFeatureEnabledAfter48() {
        const prefValue = this.force.toolingQuery(this.shapeOrg, `SELECT IsShapeExportPrefEnabled FROM ${'DevHubSettings'}`);
        // no records are returned if ShapeExportPilot perm is disabled
        return prefValue.then(value => {
            const hasResults = _.get(value, 'totalSize', 0) > 0;
            const enabled = hasResults && _.get(value, 'records[0].IsShapeExportPrefEnabled', false);
            return Promise.resolve(enabled);
        });
    }
    isShapeId(shapeId) {
        if (shapeId == null)
            return false; // '==' handles both null and undefined
        return shapeId.startsWith("3SR")
            && (shapeId.length >= 15 && shapeId.length <= 18)
            && (shapeId.match(/^[0-9a-zA-Z]+$/) != null);
    }
    async getShapeRepresentation(shapeId) {
        if (this.isShapeId(shapeId)) {
            const query = "Select Id, Status, Edition, Features, Settings from ShapeRepresentation WHERE Id = '" + shapeId + "' ";
            return this.force.query(this.shapeOrg, query)
                .catch(err => {
                return Promise.reject(err);
            });
        }
        else {
            return Promise.reject(new core_1.SfdxError(messages.getMessage('shape_get_not_a_shape_id')));
        }
    }
}
module.exports = ShapeRepresentationApi;

//# sourceMappingURL=shapeRepApi.js.map
