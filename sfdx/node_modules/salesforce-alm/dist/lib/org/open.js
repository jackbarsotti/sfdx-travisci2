"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const kit_1 = require("@salesforce/kit");
const core_1 = require("@salesforce/core");
const dns = require("dns");
const openBrowser = require("opn");
const ts_types_1 = require("@salesforce/ts-types");
const util_1 = require("util");
const lodash_1 = require("lodash");
const lookup = util_1.promisify(dns.lookup);
// Local
const Messages = require("../messages");
const messages = Messages();
const almError = require("../core/almError");
const srcDevUtil = require("../core/srcDevUtil");
const SETUP = '/setup/forcecomHomepage.apexp';
const open = {
    async buildFrontdoorUrl(org) {
        await org.refreshAuth();
        const conn = org.getConnection();
        const accessToken = conn.accessToken;
        const instanceUrl = org.getField(core_1.Org.Fields.INSTANCE_URL);
        return `${lodash_1.trimEnd(ts_types_1.asString(instanceUrl), '/')}/secur/frontdoor.jsp?sid=${accessToken}`;
    },
    /**
     * gets a url for the workspace or test org
     * @param context - the cli context
     * @param force - the force api
     * @param orgApi - an org.
     * @returns {Promise}
     * @private
     */
    buildUrl: async (org, path, isSetup = false) => {
        const url = await open.buildFrontdoorUrl(org);
        if (!path) {
            if (isSetup) {
                path = SETUP;
            }
            else {
                // Could return undefined or emptry string.
                path = kit_1.env.getString('FORCE_OPEN_URL');
            }
        }
        if (path) {
            const cleanPath = encodeURIComponent(decodeURIComponent(path));
            return `${url}&retURL=${cleanPath}`;
        }
        return url;
    },
    // Try for four minutes, by default
    getDomainRetries: () => kit_1.toNumber(kit_1.env.getString('SFDX_DOMAIN_RETRY', '240')),
    async checkDns(domain) {
        return (await lookup(domain)).address;
    },
    async delay() {
        return await kit_1.sleep(1, kit_1.Duration.Unit.SECONDS);
    },
    checkLightningDomain: async (myDomain, ux, retryCount = 0) => {
        const logger = await core_1.Logger.child('open');
        const domain = `${myDomain}.lightning.force.com`;
        try {
            // Get around typings
            const ip = await open.checkDns(domain);
            logger.debug(`Found IP ${ip} for ${domain}`);
            if (retryCount > 0) {
                ux.stopSpinner();
            }
        }
        catch (err) {
            if (retryCount >= open.getDomainRetries()) {
                logger.debug(`Did not find IP for ${domain} after ${retryCount} retries`);
                ux.stopSpinner();
                throw err;
            }
            else {
                if (retryCount === 0) {
                    // We didn't find the IP after the first try, so let the user know we are looking.
                    ux.startSpinner(messages.getMessage('openCommandDomainWaiting'));
                }
                await open.delay();
                return open.checkLightningDomain(myDomain, ux, ++retryCount);
            }
        }
    },
    _openBrowserWithUrl: async function (url) {
        await openBrowser(url, {
            wait: false
        });
    },
    /**
     * either open user's desktop browser or just print the url in console.
     * @param context - the cli context
     * @param force - the force api
     * @returns {Promise}
     * @private
     */
    open: async (org, ux, path, isSetup, urlOnly) => {
        const url = await open.buildUrl(org, path, isSetup);
        const orgId = org.getOrgId();
        const username = org.getUsername();
        const retVal = {
            url,
            orgId,
            username
        };
        const act = async () => {
            if (!urlOnly && !srcDevUtil.isSFDXContainerMode()) {
                open._openBrowserWithUrl(url);
            }
            return retVal;
        };
        if (open.getDomainRetries() === 0 || srcDevUtil.isInternalUrl(url)) {
            return act();
        }
        try {
            try {
                const myDomain = url.match(/https?\:\/\/([^.]*)/)[1];
                await open.checkLightningDomain(myDomain, ux);
                return act();
            }
            catch (err) {
                throw almError('openCommandDomainTimeoutError', null, 'openCommandDomainTimeoutAction');
            }
        }
        catch (err) {
            // Error extracting the mydomain, just return.
            return act();
        }
    }
};
exports.default = open;

//# sourceMappingURL=open.js.map
