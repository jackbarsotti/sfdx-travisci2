"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Config = require("../force-cli/force-cli-config");
const almError = require("../core/almError");
const DataBulkUpsert = require("./dataBulkUpsertCommand");
const fs = require("fs");
class DataBulkDeleteCommand {
    async execute(context) {
        let conn = await Config.getActiveConnection(context);
        let csvRecords;
        try {
            fs.statSync(context.flags.csvfile);
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return Promise.reject(almError('PathDoesNotExist', context.flags.csvfile));
            }
            else {
                throw err;
            }
        }
        csvRecords = fs.createReadStream(context.flags.csvfile);
        let job = conn.bulk.createJob(context.flags.sobjecttype, 'delete');
        return new Promise(async (resolve, reject) => {
            job.on('error', function (err) {
                reject(err);
            });
            let batches = await DataBulkUpsert.splitIntoBatches(csvRecords);
            try {
                resolve(await DataBulkUpsert.createAndExecuteBatches(conn, job, batches, context.flags.sobjecttype, context.flags.wait));
            }
            catch (e) {
                reject(e);
            }
        });
    }
}
exports.DataBulkDeleteCommand = DataBulkDeleteCommand;

//# sourceMappingURL=dataBulkDeleteCommand.js.map
