"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const Display = require("../force-cli/force-cli-display");
const Config = require("../force-cli/force-cli-config");
const Messages = require("../force-cli/force-cli-messages");
const ts_types_1 = require("@salesforce/ts-types");
const reporter_1 = require("../../lib/test/reporter");
const soqlParser_1 = require("./soqlParser");
const os_1 = require("os");
class QueryReporter extends reporter_1.Reporter {
    constructor(conn, query, logger) {
        super(logger);
        this.conn = conn;
        this.query = query;
    }
    getBaseUrl() {
        return this.conn._baseUrl();
    }
    async retrieveColumns() {
        const columnUrl = `${this.getBaseUrl()}/query?q=${encodeURIComponent(this.query)}&columns=true`;
        const results = ts_types_1.toJsonMap(await this.conn.request(columnUrl));
        this.columns = [];
        for (let column of ts_types_1.ensureJsonArray(results.columnMetadata)) {
            column = ts_types_1.ensureJsonMap(column);
            const name = ts_types_1.ensureString(column.columnName);
            if (ts_types_1.isJsonArray(column.joinColumns) && column.joinColumns.length > 0) {
                if (column.aggregate) {
                    const field = new soqlParser_1.SubqueryField(name);
                    for (const subcolumn of column.joinColumns) {
                        field.fields.push(new soqlParser_1.Field(ts_types_1.ensureString(ts_types_1.ensureJsonMap(subcolumn).columnName)));
                    }
                    this.columns.push(field);
                }
                else {
                    for (const subcolumn of column.joinColumns) {
                        this.columns.push(new soqlParser_1.Field(`${name}.${ts_types_1.ensureString(ts_types_1.ensureJsonMap(subcolumn).columnName)}`));
                    }
                }
            }
            else if (column.aggregate) {
                const field = new soqlParser_1.FunctionField(ts_types_1.ensureString(column.displayName));
                // If it isn't an alias, skip so the display name is used when messaging rows
                if (!name.match(/expr[0-9]+/)) {
                    field.alias = name;
                }
                this.columns.push(field);
            }
            else {
                this.columns.push(new soqlParser_1.Field(name));
            }
        }
        return this.columns;
    }
}
class HumanReporter extends QueryReporter {
    parseFields() {
        const fields = this.columns;
        // Field names
        let attributeNames = [];
        // For subqueries. Display the children under the parents
        const children = [];
        // For function fields, like avg(total).
        const aggregates = [];
        if (fields) {
            this.logger.info(`Found fields ${JSON.stringify(fields.map(field => `${typeof field}.${field.name}`))}`);
            fields.forEach(field => {
                if (field instanceof soqlParser_1.SubqueryField) {
                    children.push(field.name);
                    field.fields.forEach(subfield => attributeNames.push(`${field.name}.${subfield.name}`));
                }
                else if (field instanceof soqlParser_1.FunctionField) {
                    if (field.alias) {
                        attributeNames.push(field.alias);
                    }
                    else {
                        attributeNames.push(field.name);
                    }
                    aggregates.push(field);
                }
                else {
                    attributeNames.push(field.name);
                }
            });
        }
        else {
            this.logger.info(`No fields found for query "${this.query}"`);
        }
        return { attributeNames, children, aggregates };
    }
    massageRows(queryResults, children, aggregates) {
        // There are subqueries or aggregates. Massage the data.
        if (children.length > 0 || aggregates.length > 0) {
            queryResults = queryResults.reduce((newResults, result) => {
                newResults.push(result);
                // Aggregates are soql functions that aggregate data, like "SELECT avg(total)" and
                // are returned in the data as exprX. Aggregates can have aliases, like "avg(total) totalAverage"
                // and are returned in the data as the alias.
                if (aggregates.length > 0) {
                    for (let i = 0; i < aggregates.length; i++) {
                        const aggregate = aggregates[i];
                        if (!aggregate.alias) {
                            result[aggregate.name] = result[`expr${i}`];
                        }
                    }
                }
                if (children.length > 0) {
                    const childrenRows = {};
                    children.forEach(child => {
                        childrenRows[child] = result[child];
                        delete result[child];
                    });
                    _.keys(childrenRows).forEach(child => {
                        if (childrenRows[child]) {
                            childrenRows[child].records.forEach(record => {
                                const newRecord = {};
                                _.each(record, (value, key) => {
                                    newRecord[`${child}.${key}`] = value;
                                });
                                newResults.push(newRecord);
                            });
                        }
                    });
                }
                return newResults;
            }, []);
        }
        return queryResults;
    }
    onFinished(queryResults) {
        const { attributeNames, children, aggregates } = this.parseFields();
        let totalCount = queryResults.length;
        this.display(attributeNames, this.massageRows(queryResults, children, aggregates), totalCount);
        return super.onFinished(queryResults);
    }
    display(attributeNames, queryResults, totalCount) {
        Display.soqlQuery(attributeNames, queryResults, totalCount);
    }
    getFormat() {
        return 'txt';
    }
}
exports.HumanReporter = HumanReporter;
const SEPARATOR = ',';
const DOUBLE_QUOTE = '"';
const SHOULD_QUOTE_REGEXP = new RegExp(`[${SEPARATOR}${DOUBLE_QUOTE}${os_1.EOL}]`);
class CsvReporter extends QueryReporter {
    /**
     * Escape a value to be placed in a CSV row. We follow rfc 4180
     * https://tools.ietf.org/html/rfc4180#section-2 and will not surround the
     * value in quotes if it doesn't contain the separator, double quote, or EOL.
     * @param value The escaped value
     */
    escape(value) {
        if (value && _.isFunction(value.match) && value.match(SHOULD_QUOTE_REGEXP)) {
            return `"${value.replace(/"/gi, '""')}"`;
        }
        return value;
    }
    onFinished(queryResults) {
        const fields = this.columns;
        const hasSubqueries = _.some(fields, field => field instanceof soqlParser_1.SubqueryField);
        const hasFunctions = _.some(fields, field => field instanceof soqlParser_1.FunctionField);
        let attributeNames = [];
        if (fields) {
            this.logger.info(`Found fields ${JSON.stringify(fields.map(field => `${typeof field}.${field.name}`))}`);
        }
        else {
            this.logger.info(`No fields found for query "${this.query}"`);
        }
        if (hasSubqueries || hasFunctions) {
            // If there are subqueries, we need to get the max child length for each subquery.
            const typeLengths = {};
            // For function fields, like avg(total).
            const aggregates = [];
            fields.forEach(field => {
                if (field instanceof soqlParser_1.SubqueryField) {
                    typeLengths[field.name] = 0;
                }
                if (field instanceof soqlParser_1.FunctionField) {
                    aggregates.push(field);
                }
            });
            // Get max lengths by iterating over the records once
            queryResults.forEach(result => {
                _.keys(typeLengths).forEach(key => {
                    if (result[key] && result[key].totalSize > typeLengths[key]) {
                        typeLengths[key] = result[key].totalSize;
                    }
                });
                // Aggregates are soql functions that aggregate data, like "SELECT avg(total)" and
                // are returned in the data as exprX. Aggregates can have aliases, like "avg(total) totalAverage"
                // and are returned in the data as the alias.
                if (aggregates.length > 0) {
                    for (let i = 0; i < aggregates.length; i++) {
                        const aggregate = aggregates[i];
                        if (!aggregate.alias) {
                            result[aggregate.name] = result[`expr${i}`];
                        }
                    }
                }
            });
            fields.forEach(field => {
                if (typeLengths[field.name]) {
                    for (let i = 0; i < typeLengths[field.name]; i++) {
                        attributeNames.push(`${field.name}.totalSize`);
                        field.fields.forEach(subfield => {
                            attributeNames.push(`${field.name}.records.${i}.${subfield.name}`);
                        });
                    }
                }
                else if (field instanceof soqlParser_1.FunctionField) {
                    if (field.alias) {
                        attributeNames.push(field.alias);
                    }
                    else {
                        attributeNames.push(field.name);
                    }
                }
                else {
                    attributeNames.push(field.name);
                }
            });
        }
        else {
            attributeNames = fields.map(field => field.name);
        }
        this.log(attributeNames
            .map(name => {
            return this.escape(name);
        })
            .join(SEPARATOR));
        queryResults.forEach(row => {
            const values = attributeNames.map(name => {
                return this.escape(_.get(row, name));
            });
            this.log(values.join(SEPARATOR));
        });
        return super.onFinished(queryResults);
    }
    getFormat() {
        return 'csv';
    }
}
exports.CsvReporter = CsvReporter;
class JsonReporter extends QueryReporter {
    onFinished(queryResults) {
        // We can only log to streams because the CLI process logs the json to stdout.
        this.logToStreams(JSON.stringify(queryResults));
        return super.onFinished(queryResults);
    }
    log(msg) { }
    logTable(header, data, columns) { }
    getFormat() {
        return 'json';
    }
}
exports.JsonReporter = JsonReporter;
/**
 * A list of the accepted reporter types
 */
exports.FormatTypes = {
    human: HumanReporter,
    csv: CsvReporter,
    json: JsonReporter
};
class DataSoqlQueryCommand {
    validate(context) {
        if (context.flags.json) {
            context.flags.resultformat = 'json';
        }
        else if (context.flags.resultformat === 'json') {
            // If the result format is json, make sure the context is too
            context.flags.json = true;
        }
        return context;
    }
    async execute(context) {
        const logger = context.logger;
        const resultFormat = context.flags.resultformat || 'human';
        if (!exports.FormatTypes[resultFormat]) {
            throw Error(Messages.get('DataSOQLQueryInvalidReporter', Object.keys(exports.FormatTypes)));
        }
        if (context.flags.query) {
            let conn = await Config.getActiveConnection(context);
            if (context.flags.usetoolingapi) {
                conn = conn.tooling;
            }
            // Reporter requires a legacy logapi type
            const reporter = new exports.FormatTypes[resultFormat](conn, context.flags.query, logger);
            return await conn.query(context.flags.query, undefined, async function (err, result) {
                return await handleResults(conn, err, result, reporter);
            });
        }
        else {
            throw Error(context.command);
        }
    }
}
exports.DataSoqlQueryCommand = DataSoqlQueryCommand;
/**
 * get attribute names from the query using the antlr parser
 * @param {string} query - the query
 * @returns {string[]}
 */
exports.getAllAttributesNames = function (query, logger) {
    return soqlParser_1.getFields(query, logger);
};
let handleResults = async function (conn, err, result, reporter) {
    if (err) {
        throw Error(err.message);
    }
    if (result.records && result.records.length > 0) {
        await reporter.retrieveColumns();
        // get all result batches
        let moreResults = result;
        while (!moreResults.done) {
            if (moreResults.nextRecordsUrl) {
                moreResults = await conn.queryMore(moreResults.nextRecordsUrl);
                if (moreResults.records) {
                    result.records = result.records.concat(moreResults.records);
                }
                else {
                    throw Error(Messages.get('DataSOQLQueryMoreMissingRecords'));
                }
            }
            else {
                throw Error(Messages.get('DataSOQLQueryMoreMissingUrl'));
            }
        }
        if (result.records) {
            reporter.emit('finished', result.records);
        }
        else {
            throw Error(Messages.get('DataSOQLQueryMoreMissingRecords'));
        }
    }
    else if (!(reporter instanceof JsonReporter)) {
        Display.info(Messages.get('DataSOQLQueryNoResults'));
    }
    // Clean result for consumer
    delete result.nextRecordsUrl;
    result.done = true;
    return result;
};

//# sourceMappingURL=dataSoqlQueryCommand.js.map
