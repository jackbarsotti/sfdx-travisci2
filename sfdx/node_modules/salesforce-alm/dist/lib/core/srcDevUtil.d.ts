import { Env } from '@salesforce/kit';
import * as _ from 'lodash';
declare function parseJSON(data: any, jsonPath: any, throwOnEmpty?: boolean): any;
declare const self: {
    isSFDXContainerMode(env?: Env): boolean;
    queryOrgInfoFromDevHub(hubOrg: any, orgId: any): any;
    /**
     * Returns whether the org has source tracking ability.
     * @param {string} username the org username
     * @returns {boolean}
     */
    isSourceTrackedOrg(username: any): Promise<boolean>;
    /**
     * Recursively act on all files or directories in a directory
     */
    actOn(dir: any, perform: any, onType?: any): void;
    readJSONSync(jsonPath: any, throwOnEmpty?: boolean): any;
    /**
     * Read a file and convert it to JSON
     *
     * @param {string} jsonPath The path of the file
     * @return {BBPromise} promise The contents of the file as a JSON object
     */
    readJSON(jsonPath: any, throwOnEmpty?: boolean): any;
    parseJSON: typeof parseJSON;
    /**
     * Helper for handling errors resulting from reading and then parsing a JSON file
     * @param e - the error
     * @param filePath - the filePath to the JSON file being read
     */
    processReadAndParseJsonFileError(e: any, filePath: any): any;
    /**
     * simple helper for creating an error with a name.
     * @param message - the message for the error
     * @param name - the name of the error. preferably containing no spaces, starting with a capital letter, and camel-case.
     * @returns {Error}
     */
    getError(message: any, name: any): Error;
    /**
     * function that normalizes cli args between yargs and heroku toolbelt
     * @param context - the cli context
     * @returns {object}
     */
    fixCliContext(context: any): any;
    /**
     * Simple helper method to determine that the path is a file (all SFDX files have an extension)
     * @param localPath
     * @returns {boolean}
     */
    containsFileExt(localPath: any): boolean;
    /**
     * Simple helper method to determine if a fs path exists.
     * @param localPath The path to check. Either a file or directory.
     * @returns {boolean} true if the path exists false otherwise.
     */
    pathExistsSync(localPath: any): any;
    /**
     * Ensure that a directory exists, creating as necessary
     * @param localPath The path to the directory
     */
    ensureDirectoryExistsSync(localPath: any): void;
    /**
     * If a file exists, delete it
     * @param localPath - Path of the file to delete.
     */
    deleteIfExistsSync(localPath: any): void;
    /**
     * If a directory exists, force remove it and anything inside
     * @param localPath - Path of the directory to delete.
     */
    deleteDirIfExistsSync(localPath: any): void;
    /**
     * If a directory exists, return all the items inside of it
     * @param localPath - Path of the directory
     * @param deep{boolean} - Whether to include files in all subdirectories resursively
     * @param excludeDirs{boolean} - Whether to exclude directories in the returned list
     * @returns {Array} - files in directory
     */
    getDirectoryItems(localPath: string, deep?: boolean, excludeDirs?: boolean): any[];
    /**
     * Return filepath of the global file in $HOME/.sfdx.
     *
     * @returns String
     */
    getGlobalFilePath(jsonConfigFileName: any): string;
    getGlobalHiddenFolder(): string;
    /**
     * Helper method for removing config file data from .sfdx.
     * @param jsonConfigFileName The name of the config file stored in .sfdx.
     * @returns BBPromise
     */
    deleteGlobalConfig(jsonConfigFileName: any): any;
    /**
     * Helper method for getting config file data from $HOME/.sfdx.
     * @param {string} jsonConfigFileName The name of the config file stored in .sfdx.
     * @param {object} defaultIfNotExist A value returned if the files doesn't exist. It not set, an error would be thrown.
     * @returns {BBPromise<object>} The resolved content as a json object.
     */
    getGlobalConfig(jsonConfigFileName: any, defaultIfNotExist?: any): any;
    /**
     * Synchronous version of getAppConfig.
     * @deprecated
     */
    getGlobalConfigSync(jsonConfigFileName: any): any;
    /**
     * Determines if a value is an object {}.
     * @param {object} value - language value of an object
     * @returns {boolean} - true only if value is an object and not a function or an array.
     */
    isObject(value: any): boolean;
    /**
     * Helper method for saving config files to .sfdx.
     * @param config The config.json configuration object.
     * @param jsonConfigFileName The name for the config file to store in .sfdx.
     * @param jsonConfigObject The json object to store in .sfdx/[jsonConfigFileName]
     * @returns BBPromise
     */
    saveGlobalConfig(jsonConfigFileName: any, jsonConfigObject: any): any;
    /**
     * Get the name of the directory containing workspace state
     * @returns {string}
     */
    getWorkspaceStateFolderName(): string;
    getConfigFileName(): string;
    /**
     * Get the full path to the file storing the workspace org config information
     * @param wsPath - The root path of the workspace
     * @returns {*}
     */
    getWorkspaceOrgConfigPath(wsPath: any): string;
    /**
     * Return true is the url is a local or vpod url and not a production url.
     * @param url - url to host resource
     * @returns {boolean}
     */
    isInternalUrl(url: any): any;
    /**
     * Returns true if a provided url is Salesforce owned.
     * @param {*} urlString
     */
    isSalesforceDomain(urlString: any): boolean;
    /**
     * Helper function that returns true if a value is an integer.
     * @param value the value to compare
     * @returns {boolean} true if value is an integer. this is not a mathematical definition. that is -0 returns true.
     * this is in intended to be followed up with parseInt.
     */
    isInt(value: any): boolean;
    /**
     * Validate that user name is valid by checking we have an auth record.
     * @param username - username for the target org
     * @returns {boolean}
     */
    isUsernameValid(username: any): any;
    /**
     * Execute each function in the array sequentially.
     *
     * @param promiseFactories  An array of functions to be executed that return BBPromises.
     * @returns {BBPromise.<T>}
     */
    sequentialExecute(promiseFactories: any): any;
    /**
     * Execute each function in the array in parallel.
     *
     * @param promiseFactories  An array of functions to be executed that return BBPromises.
     * @returns {BBPromise.<*>}
     */
    parallelExecute(promiseFactories: any): any;
    /**
     * Given a request object or string url a request object is returned with the additional http headers needed by force.com
     * @param {(string|object)} request - A string url or javascript object.
     * @param options - {object} that may contain headers to add to request
     * @returns {object} a request object containing {method, url, headers}
     */
    setSfdxRequestHeaders(request: any, options?: any): any;
    getSfdxRequestHeaders(): {
        'content-type': string;
        'user-agent': string;
    };
    getSfdxCLIClientId(): string;
    isVerbose(): boolean;
    trimTo15(id: any): any;
    /**
     * @returns {boolean} returns true if process.env.SFDX_USE_GENERIC_UNIX_KEYCHAIN is set to true.
     */
    useGenericUnixKeychain(): boolean;
    stripWhitespace(document: any): void;
    /**
     * Zips directory to given zipfile.
     *
     * https://github.com/archiverjs/node-archiver
     *
     * @param dir to zip
     * @param zipfile
     * @param options
     */
    zipDir(dir: any, zipfile: any, options?: {}): any;
    setZipDirPath(path: string): void;
    getZipDirPath(): string;
    getElapsedTime(timer: any): string;
    /**
     *  Uses Lodash _.mapKeys to convert object keys to another format using the specified conversion function.
     *
     *  E.g., to deep convert all object keys to camelCase:  mapKeys(myObj, _.camelCase, true)
     *        to shallow convert object keys to lower case:  mapKeys(myObj, _.toLower)
     *
     *  NOTE: This mutates the object passed in for conversion.
     *
     *  @param obj - {Object} The object to convert the keys
     *  @param converterFn - {Function} The function that converts the object key
     *  @param deep - {boolean} Whether to do a deep object key conversion
     *  @return {Object} - the object with the converted keys
     */
    mapKeys(obj: any, converterFn: any, deep?: any): _.Dictionary<any>;
    toLowerCaseKeys(obj: any, deep?: any): any;
    /**
     *  Returns the first key within the object that has an upper case first letter.
     *
     *  @param obj - {Object} The object to check key casing
     *  @param blocklist - don't include results in this array
     *  @return {string} - the key that starts with upper case
     */
    findUpperCaseKeys(obj: any, blocklist?: any[]): any;
    /**
     * Helper to make a nodejs base64 encoded string compatible with rfc4648 alternative encoding for urls.
     * @param {string} base64Encoded - a nodejs base64 encoded string
     * @returns {string} returns the string escaped.
     */
    base64UrlEscape(base64Encoded?: any): string;
    /**
     * Helper that will un-escape a base64 url encoded string.
     * @param {string} base64EncodedAndEscaped - the based 64 escaped and encoded string.
     * @returns {string} returns the string un-escaped.
     */
    base64UrlUnEscape(base64EncodedAndEscaped: any): string;
    getContentHash(contents: any): string;
    /**
     * Logs the collection of unsupported mime types to the server
     * @param unsupportedMimeTypes
     * @param _logger
     * @param force
     */
    logUnsupportedMimeTypeError(unsupportedMimeTypes: any, _logger: any, force: any): Promise<any>;
    areFilesEqual(file1Path: any, file2Path: any): boolean;
};
export = self;
