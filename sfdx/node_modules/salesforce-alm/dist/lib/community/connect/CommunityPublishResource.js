"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CommunitiesServices_1 = require("../service/CommunitiesServices");
const sfdxError_1 = require("@salesforce/core/lib/sfdxError");
const url_1 = require("url");
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const communityMessages = core_1.Messages.loadMessages('salesforce-alm', 'community_commands');
/**
 * A connect api resource for publishing a community
 */
class CommunityPublishResource {
    constructor(flags, org, ux) {
        this.flags = flags;
        this.org = org;
        this.ux = ux;
    }
    async fetchRelativeConnectUrl() {
        return `/connect/communities/${await this.fetchCommunityId()}/publish`;
    }
    getRequestMethod() {
        return 'POST';
    }
    async fetchPostParams() {
        return JSON.stringify({});
    }
    handleSuccess(result) {
        const response = {
            id: result['id'],
            message: communityMessages.getMessage('publish.response.message'),
            name: result['name'],
            status: this.info.status,
            url: new url_1.URL(result['url'])
        };
        const columns = ['id', 'message', 'name', 'status', 'url'];
        this.ux.styledHeader(communityMessages.getMessage('publish.response.styleHeader'));
        this.ux.table([response], columns);
        return response;
    }
    handleError(error) {
        throw error;
    }
    async fetchCommunityId() {
        this.info = await CommunitiesServices_1.CommunitiesServices.fetchCommunityInfoFromName(this.org, this.flags.name);
        if (!this.info) {
            throw sfdxError_1.SfdxError.create('salesforce-alm', 'community_commands', 'publish.error.communityNotExists', [
                this.flags.name
            ]);
        }
        return this.info.id;
    }
}
exports.CommunityPublishResource = CommunityPublishResource;

//# sourceMappingURL=CommunityPublishResource.js.map
