import { Dictionary } from '@salesforce/ts-types';
/**
 * A Reporter outputs progress and results to stdout and, optionally, different
 * streams. This is an abstract class. Different implementations can specify
 * the output format hey want to report for the command.
 *
 * Many events can call into a reporter, which means that async events on
 * a progress event may not finish before the next event is sent in. For example:
 *    1. a client (like streaming) is listening for events
 *    2. a progress event comes in and emits progress on the reporter and waits
 *    3. a finish event comes in and emits finish on the reporter and waits
 *
 * Even though the #2 is waiting, node will still hit #3 because the way events
 * work in node. Therefore, if any part of the reporter needs to preform an async
 * operation, it must be added to the operations array.
 *    this.operations.push(promise);
 *
 * Finish will wait for all operations to finish before returning.
 */
export declare class Reporter {
    static Types: Dictionary<any>;
    [property: string]: any;
    constructor(parentLogger?: any);
    /**
     * We must pipe stdout to the stream while this reporter lives because
     * there are several calls to logger (like table) which does a lot of logic
     * before writing directly to stdout.
     */
    addStream(stream: any): void;
    log(msg?: any): void;
    logToStreams(msg: any): void;
    /**
     * Log some test information to the console, but only log when json is not
     * specified. Otherwise the only output should be in json format which will
     * print to the console when the command returns on the command handler.
     * @param {string} header The header for the table OR a string if no table
     *    (object) is specified.
     * @param {object|array} data The data to display in the table. Data will be
     *    converted to an array if an object is passed in.
     * @param {array} columns An array of column information, such as key, label,
     * and formatter.
     */
    logTable(header: any, data: any, columns: any): void;
    onStart(data?: any): void;
    /**
     * Does this Reporter need progress information.
     */
    get progressRequired(): boolean;
    /**
     * Determine if this is a specific Reporter type instance.
     *
     * @param {class} type The type of Reporter to check if this is an instanceof.
     */
    isType(type: any): boolean;
    /**
     * The function to call when the command has finished.
     *
     * @param {Object} results The completed results
     */
    onFinished(data?: any): Promise<void>;
    /**
     * The type of output this reporter produces, like the file format which
     * makes this useful for file extensions.
     * i.e. xml, json, txt, etc.
     *
     * This method must be implemented.
     *
     * @param {Object} results The completed results
     */
    getFormat(): void;
    emit(event: any, data: any): any;
}
/**
 * Output the test results in a human readable way
 */
export declare class HumanReporter extends Reporter {
    constructor(parentLogger: any, config: any);
    getTable(): ({
        key: string;
        label: string;
        format?: undefined;
    } | {
        key: string;
        label: string;
        format: (outcome: any) => any;
    } | {
        key: string;
        label: string;
        format: (msg: any, row: any) => string;
    })[];
    logResultsTable(testResults: any): void;
    logSummaryTable(testResults: any): void;
    logFailuresTable(testResults: any): void;
    _findFile(filename: any): any;
    logTables(testResults: any): void;
    onFinished(testResults: any): Promise<void>;
    getFormat(): string;
}
/**
 * This is a special reporter that only logs to streams. This is because the CLI has
 * a global 'json' flag that outputs JSON to stdout, and requires that the JSON
 * be returned from the command. So we do not log to stdout here so we don't print JSON
 * twice.
 */
export declare class JsonReporter extends Reporter {
    onFinished(testResults: any): Promise<void>;
    log(msg: any): void;
    logTable(header: any, data: any, columns: any): void;
    getFormat(): string;
}
/**
 * No-op report, but does provide logging utility.
 */
export declare class NoOpReporter extends Reporter {
    addStream(): void;
}
/**
 * Outputs test results in JUnit format, particularly useful for CI tools.
 */
export declare class JUnitReporter extends Reporter {
    onFinished(testResults: any): Promise<void>;
    log(): void;
    getFormat(): string;
}
/**
 * A TAP reporter. https://testanything.org
 *
 * TAP is specifically useful for streaming results to the client, so this
 * reporter listens for test progress.
 */
export declare class TapReporter extends Reporter {
    constructor(parentLogger: any);
    /**
     * Logs messages that are ignored by TAP parsing, eg directives, comments,
     * and general log lines.
     *
     * Use logTap to log parsable TAP output.
     *
     * @param msg
     */
    log(msg: any): void;
    logTap(msg: any): void;
    logTable(header: any, data: any, columns: any): void;
    logTapStart(testCnt: any): void;
    /**
     * Receive notifications on progress to output TAP lines as the tests finish.
     * NOTE: This will use more API calls since it will query the queue items every
     *  streaming event.
     */
    onProgress(data?: any): Promise<void>;
    /**
     * Construct TAP formatted line.
     *
     * @param testResult
     */
    logTapResult(testResult: any): void;
    getFullTestName(testResult: any): void;
    getFormat(): string;
}
