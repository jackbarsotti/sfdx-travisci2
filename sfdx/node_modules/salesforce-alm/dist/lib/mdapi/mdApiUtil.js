"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*
    MDAPI utility. This is not complete. Adding this to move a REST deploy related method out of force.js
    We need to refactor code and probably move more MD common functionality here.
*/
const core_1 = require("@salesforce/core");
core_1.Messages.importMessagesDirectory(__dirname);
const configApi_1 = require("../core/configApi");
class MetadataConnection extends core_1.Connection {
    // TODO: A method should be added to jsforce for deployRecentValidation()
    async _mdapiSoapDeployRecentValidation(options, connection) {
        let result;
        try {
            result = await connection.metadata['_invoke']('deployRecentValidation', {
                validationId: options.validateddeployrequestid
            });
        }
        catch (err) {
            throw err;
        }
        return result;
    }
    async _mdapiRestDeployRecentValidation(options, connection) {
        const validateddeployrequestid = options.validateddeployrequestid;
        const url = `${connection.instanceUrl}/services/data/v${connection.getApiVersion()}/metadata/deployRequest`;
        const messageBody = JSON.stringify({
            validatedDeployRequestId: validateddeployrequestid
        });
        const requestInfo = {
            method: 'POST',
            url,
            body: messageBody
        };
        const requestOptions = { headers: 'json' };
        let body;
        try {
            body = await connection.request(requestInfo, requestOptions);
        }
        catch (err) {
            if (err.name === 'API_DISABLED_FOR_ORG') {
                throw core_1.SfdxError.create('salesforce-alm', 'mdapi_deploy', 'mdDeployCommandCliNoRestDeploy');
            }
            else {
                throw err;
            }
        }
        return body;
    }
}
exports.MetadataConnection = MetadataConnection;
// Get a @salesforce/core Connection, which extends jsforce.Connection.
async function getMetadataConnection(orgApi) {
    const connection = await core_1.Connection.create({
        authInfo: await core_1.AuthInfo.create({
            username: orgApi.getName()
        })
    });
    connection.setApiVersion(new configApi_1.Config().getApiVersion());
    return connection;
}
exports.getMetadataConnection = getMetadataConnection;
//metadata api deploy recent validation; options contains the validated job ID to deployed
async function mdapiDeployRecentValidation(orgApi, options) {
    let connection = await this.getMetadataConnection(orgApi);
    const restDeploy = await MetadataTransportInfo.isRestDeploy();
    if (restDeploy) {
        this.logger = await core_1.Logger.child('*** Deploying with REST ***');
        return MetadataConnection.prototype._mdapiRestDeployRecentValidation(options, connection);
    }
    else {
        return MetadataConnection.prototype._mdapiSoapDeployRecentValidation(options, connection);
    }
}
exports.mdapiDeployRecentValidation = mdapiDeployRecentValidation;
class MetadataTransportInfo {
    static async isRestDeploy() {
        const aggregator = await core_1.ConfigAggregator.create();
        const restDeploy = aggregator.getPropertyValue('restDeploy');
        return restDeploy && restDeploy.toString() === 'true';
    }
    static async isRestDeployWithWaitZero(options) {
        const restDeploy = await this.isRestDeploy();
        return restDeploy && options.wait === 0;
    }
    static validateExclusiveFlag(options, param1, param2) {
        if (options[param1] && options[param2]) {
            throw core_1.SfdxError.create('salesforce-alm', 'mdapi_deploy', 'mdapiCliExclusiveFlagError', [param1, param2]);
        }
    }
}
exports.MetadataTransportInfo = MetadataTransportInfo;

//# sourceMappingURL=mdApiUtil.js.map
