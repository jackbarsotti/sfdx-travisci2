"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
// 3pp
const mkdirp = require("mkdirp");
const BBPromise = require("bluebird");
// Local
const logger = require("../core/logApi");
const almError = require("../core/almError");
const mdApiUtil = require("./mdApiUtil");
const fs = BBPromise.promisifyAll(require('fs'));
/**
 * API that wraps Metadata API to retrieve listmetadata result.
 *
 * @param force
 * @constructor
 */
class MdListmetadataApi {
    constructor(org) {
        this.org = org;
        this.force = org.force;
        this.logger = logger.child('md-listmetadata');
    }
    // retreive source from org
    async retrieve(context) {
        const options = context.flags;
        // set target org, org other than workspace defined org
        const orgApi = this.org;
        if (options.resultfile) {
            this.retrieveTargetPath = path.resolve(options.resultfile);
        }
        const retrieveOptions = await this.formatRetrieveOptions(options);
        const result = await this.retrieveListmetadata(orgApi, retrieveOptions);
        if (this.retrieveTargetPath) {
            return this.createOutputJSONResultFile(this.retrieveTargetPath, result, this);
        }
        else {
            this.print(result);
            return result;
        }
    }
    async retrieveListmetadata(orgApi, retrieveOptions) {
        const connection = await mdApiUtil.getMetadataConnection(orgApi);
        const listmetadataQuery = this.getListmetadataQuery(retrieveOptions);
        return connection.metadata.list(listmetadataQuery, retrieveOptions.apiVersion);
    }
    getListmetadataQuery(retrieveOptions) {
        return new ListmetadataQuery(retrieveOptions.metadatatype, retrieveOptions.folder);
    }
    async createOutputJSONResultFile(retrieveTargetPath, resultJson, mdApi) {
        try {
            await fs.accessAsync(path.dirname(mdApi.retrieveTargetPath));
        }
        catch (err) {
            mkdirp.sync(path.dirname(mdApi.retrieveTargetPath));
        }
        const fileName = retrieveTargetPath;
        const json = JSON.stringify(resultJson);
        await fs.writeFileAsync(fileName, json);
        this.print(`Wrote result file to ${fileName}.`);
        return { message: `Wrote result file to ${fileName}.` };
    }
    formatRetrieveOptions(options) {
        const retrieveOptions = {};
        retrieveOptions.apiVersion = options.apiversion || this.force.config.getApiVersion();
        retrieveOptions.resultfile = options.resultfile;
        retrieveOptions.targetusername = options.targetusername;
        retrieveOptions.metadatatype = options.metadatatype;
        retrieveOptions.folder = options.folder;
        return retrieveOptions;
    }
    print(message) {
        this.logger.log(message);
    }
    async validate(context) {
        const options = context.flags;
        const currentApiVersion = this.force.config.getApiVersion();
        if (options.apiversion &&
            (isNaN(+options.apiversion) || +options.apiversion < 0 || +options.apiversion > currentApiVersion)) {
            throw almError('mdListmetadataCommandCliInvalidApiVersionError', currentApiVersion);
        }
        if (options.resultfile) {
            const retrieveTargetPath = path.resolve(options.resultfile);
            try {
                const data = await fs.statAsync(retrieveTargetPath);
                if (!data.isFile()) {
                    throw almError('InvalidArgumentFilePath', ['resultfile', retrieveTargetPath]);
                }
            }
            catch (err) {
                if (err.code !== 'ENOENT') {
                    throw err;
                }
            }
        }
    }
}
exports.MdListmetadataApi = MdListmetadataApi;
class ListmetadataQuery {
    constructor(metadatatype, folder) {
        this.type = metadatatype;
        if (folder) {
            this.folder = folder;
        }
    }
}

//# sourceMappingURL=mdapiListmetadataApi.js.map
