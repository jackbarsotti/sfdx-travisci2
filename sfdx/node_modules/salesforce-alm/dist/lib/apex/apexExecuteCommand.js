"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ResponseParser = require("../force-cli/force-cli-responseParser");
const Display = require("../force-cli/force-cli-display");
const CliError = require("../force-cli/force-cli-error");
const Config = require("../force-cli/force-cli-config");
const Messages = require("../force-cli/force-cli-messages");
const fs = require("fs");
const util = require("util");
const readline = require("readline");
const soapTemplate = `<env:Envelope xmlns:xsd="http://www.w3.org/2001/XMLSchema"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"
		xmlns:cmd="http://soap.sforce.com/2006/08/apex"
		xmlns:apex="http://soap.sforce.com/2006/08/apex">
			<env:Header>
				<cmd:SessionHeader>
					<cmd:sessionId>%s</cmd:sessionId>
				</cmd:SessionHeader>
				%s
			</env:Header>
			<env:Body>
				<%s xmlns="http://soap.sforce.com/2006/08/apex">
				    %s
				</%s>
			</env:Body>
		</env:Envelope>`;
class ApexExecuteCommand {
    validate(context) { }
    async execute(context) {
        if (context.flags.apexcodefile === undefined) {
            return await exports.apexFromUserInput(context);
        }
        else if (context.flags.apexcodefile) {
            return await exports.apexFromFile(context);
        }
        CliError.exitDisplayHelp(context.command);
    }
}
exports.ApexExecuteCommand = ApexExecuteCommand;
/**
 * get apex code from stdin when no filepath arg provided
 * exposed for unit testing (mocked)
 */
exports.apexFromUserInput = function (context) {
    Display.info(Messages.get('ApexExecTypingPrompt'));
    return new Promise((resolve, reject) => {
        let readInterface = readline.createInterface(process.stdin, process.stdout);
        let apexCode = '';
        readInterface
            .on('line', function (input) {
            apexCode = apexCode + input + '\n';
        })
            .on('close', async function () {
            try {
                const response = await exports.execute(context, apexCode);
                resolve(exports.handleResult(ResponseParser.getExecuteAnonymousResponse(response), ResponseParser.getDebugInfo(response), context.flags.json));
            }
            catch (err) {
                reject(err);
            }
        })
            .on('error', err => reject(err));
    });
};
/**
 *  get apex code from provided file
 *  exposed for unit testing (mocked)
 *  @param {string} filepath - file containing apex code
 */
exports.apexFromFile = async function (context) {
    const data = fs.readFileSync(context.flags.apexcodefile);
    const response = await exports.execute(context, data.toString());
    return exports.handleResult(ResponseParser.getExecuteAnonymousResponse(response), ResponseParser.getDebugInfo(response), context.flags.json);
};
/**
 * creates and sends SOAP request
 * exposed for unit testing
 * @param {string} apexCode - code to debug
 * @param {function} callback - function that accepts the xml response from the server
 */
exports.execute = async function (context, apexCode) {
    // fetch saved connection to send the execute request on
    const connection = await Config.getActiveConnection(context);
    // create the exec anonymous request
    const action = 'executeAnonymous';
    const debugHeader = '<apex:DebuggingHeader><apex:debugLevel>DEBUGONLY</apex:debugLevel></apex:DebuggingHeader>';
    let actionBody = '<apexcode><![CDATA[%s]]></apexcode>';
    actionBody = util.format(actionBody, apexCode);
    const postEndpoint = connection.instanceUrl + '/services/Soap/s/' + connection.version + '/' + connection.accessToken.split('!')[0];
    const requestHeaders = {
        'Content-Type': 'text/xml',
        soapaction: action
    };
    const request = {
        method: 'POST',
        url: postEndpoint,
        body: util.format(soapTemplate, connection.accessToken, debugHeader, action, actionBody, action),
        headers: requestHeaders
    };
    const postOptions = {
        headers: Object.assign({}, requestHeaders)
    };
    return await connection.request(request, postOptions);
};
/**
 *  output results to user
 *  exposed for unit testing
 *  @param {ExecuteAnonymousResult} result
 *  @param {string} debugInfo
 */
exports.handleResult = function (result, debugInfo, json) {
    // check for compile errors
    if (result.compiled) {
        Display.success(Messages.get('ApexExecCompileSuccess'));
    }
    else {
        let errMsg = Messages.get('ApexExecCompileFailedErrorMessage', result.line, result.column, result.compileProblem);
        if (!json)
            CliError.errorMessage(errMsg);
        CliError.exitWithMessage(errMsg);
    }
    // check for runtime erorrs
    if (result.success) {
        Display.success(Messages.get('ApexExecExecutionSuccess'));
        Display.info(debugInfo);
    }
    else {
        if (!json && result.exceptionMessage)
            CliError.errorMessage(result.exceptionMessage);
        if (!json && result.exceptionStackTrace)
            CliError.errorMessage(result.exceptionStackTrace);
        const err = new Error(result.exceptionStackTrace || Messages.get('ApexExecExecutionFailure'));
        Object.assign(result, { logs: debugInfo });
        throw Object.assign(err, { result });
    }
    return Object.assign(result, { logs: debugInfo });
};

//# sourceMappingURL=apexExecuteCommand.js.map
