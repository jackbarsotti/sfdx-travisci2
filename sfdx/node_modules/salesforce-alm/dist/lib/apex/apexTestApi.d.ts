import { HumanReporter, TapReporter, JUnitReporter, JsonReporter } from '../test/reporter';
import { Dictionary } from '@salesforce/ts-types';
/**
 * Output the test results in a human readable way
 */
declare class ApexHumanReporter extends HumanReporter {
    constructor(testApi: any);
    static getDefaultCodeCoveragePercentage(): number;
    onFinished(apexTestResults: any): Promise<void>;
}
/**
 * Apex TAP reporter implementation.
 */
declare class ApexTapReporter extends TapReporter {
    constructor(testApi: any);
    onStart(testrunid: any): any;
    /**
     * Receive notifications on progress to output TAP lines as the tests finish.
     * NOTE: This will use more API calls since it will query the queue items every
     *  streaming event.
     */
    onProgress(queueItems: any): any;
    getFullTestName(testResult: any): string;
    onFinished(apexTestResults: any): Promise<void>;
}
declare class ApexJUnitReporter extends JUnitReporter {
    constructor(testApi: any);
}
declare class ApexJsonReporter extends JsonReporter {
    constructor(testApi: any);
}
/**
 * A list of the accepted reporter types
 */
export declare const ReporterTypes: {
    human: typeof ApexHumanReporter;
    tap: typeof ApexTapReporter;
    json: typeof ApexJsonReporter;
    junit: typeof ApexJUnitReporter;
};
export declare class ApexTestApi {
    static TEST_LEVELS: {
        all: string;
        local: string;
        specific: string;
    };
    static ApexHumanReporter: typeof ApexHumanReporter;
    [property: string]: any;
    /**
     * The API class that manages running of apex tests. By default it will run
     * all local namespaced tests unless initialized with other options.
     *
     * @param org {object} The org for running tests.
     */
    constructor(org: any);
    /**
     * Sets the function to call once the StreamClient socket times out
     * @param callback {function} - the function to invoke;
     */
    set socketTimeoutHandler(callback: any);
    /**
     * Gets the socket timeout handler function.
     * @returns {function}
     */
    get socketTimeoutHandler(): any;
    /**
     * Sets the wait timeout in minutes
     * @param value {number} - wait timeout in minutes
     */
    set waitInMinutes(value: any);
    /**
     * Sets the get timeout in minutes
     * @returns {number}
     */
    get waitInMinutes(): any;
    hasOutputDirectory(): boolean;
    /**
     * Create the output directory the the test results will be stored if doesn't exist
     */
    setupOutputDirectory(): any;
    /**
     * Initialize the apex test api to specify additional options and setup the
     * output directory if needed.
     *
     * @param {object} options The options used to run the tests. You can see a
     * list of valid options in the by looking at the defaults in the constructor.
     * @param {object} logger The logger object, which should typically be the
     * heroku cli.
     */
    initialize(options?: Dictionary<any>): any;
    getResultFilePath(): string;
    isRunAllTest(): boolean;
    /**
     * Map the results to an array of ids.
     * TODO this should be removed when we can pass names to the server.
     */
    resultToIds(nameField: any, result: any, original: any): any[];
    /**
     * Assemble tests config as array of classnames only.
     *
     * https://developer.salesforce.com/docs/atlas.en-us.api_tooling.meta/api_tooling/intro_rest_resources.htm
     */
    assembleClassnameConfig(): any;
    /**
     * Assemble tests config as array of classnames only.
     *
     * https://developer.salesforce.com/docs/atlas.en-us.api_tooling.meta/api_tooling/intro_rest_resources.htm
     */
    querySuiteIds(): any;
    /**
     * Assemble tests config as array of classnames or classids and testMethods to run, if applicable.
     *
     * https://developer.salesforce.com/docs/atlas.en-us.api_tooling.meta/api_tooling/intro_rest_resources.htm
     *
     * @param testsToRun - comma-delimited list
     */
    assembleTestsConfig(testsToRun?: any[]): any;
    queryNamespaces(): any;
    /**
     * Run the tests specified on this apexTestApi object by creating an apex
     * test run job. Depending on the options specified in this apexTestApi,
     * it will also wait for those results via the streaming API which will
     * also log and store those results.
     */
    runTests(): any;
    processResultId(results: any): any;
    checkProgress(): any;
    retrieveJobStatus(): any;
    handleTimeout(message: any): any;
    handleMessage(message: any): any;
    waitForResult(): any;
    isJobFinished(status: any): boolean;
    jobCheck(): any;
    queryApexCodeCoverage(testClasses?: any[], queryCharacterLimit?: number): Promise<{
        orgWideCoverage: number;
        records: any[];
    }>;
    /**
     * Retrieve the test results and code coverage for the completed queued items,
     * then store them by logging the test results to the client and filesystem.
     *
     * @param {array} apexTestQueueItemIds An array of *completed* apex queue record Ids.
     */
    retrieveAndStoreTestResults(apexTestQueueItemIds: any): any;
    /**
     * Log test results to the console and/or the filesystem depending on the options
     */
    logTestArtifacts(): any;
    /**
     * Apex code coverage has a record for each test method invoked multiplied by the
     * apex class or triggers executed in those tests. This method iterates over
     * all those records to determine the code coverage per class and trigger.
     *
     * For example, it we have testMethod1 that executes code on classA and classB, and
     * testMethod2 that executes code on classA, then there will be 3 apex code coverage
     * records: testMethod1.classA, testMethod1.classB, testMethod2.classA. That means
     * that the TOTAL lines covered in classA is an aggregate between the testMethod1
     * and testMethod2 coverage records.
     */
    retrieveApexCodeCoverage(): any;
    convertSynchronousResultsToApexTestResult(successes: any, failures: any): any[];
    convertSynchronousResultsToRunSummary(result: any): {
        TestTime: any;
    };
}
export {};
