"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@salesforce/core");
const Alias = require("../core/alias");
const kit_1 = require("@salesforce/kit");
const requestPromise = require("request-promise-native");
const core_2 = require("@salesforce/core");
const Org = require("../core/scratchOrgApi");
const configApi_1 = require("../core/configApi");
const core_3 = require("@salesforce/core");
const urls = require('../urls');
core_2.Messages.importMessagesDirectory(__dirname);
const defaultConnectedAppInfo = require('../core/defaultConnectedApp');
var LogLevel;
(function (LogLevel) {
    LogLevel["ERROR"] = "error";
    LogLevel["WARN"] = "warn";
    LogLevel["INFO"] = "info";
    LogLevel["DEBUG"] = "debug";
})(LogLevel || (LogLevel = {}));
class DeviceFlowService extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        // Public
        this.request = requestPromise;
        this.pollingCount = 0;
        this.clientId = options.clientid;
        this.instanceUrl = options.instanceurl;
        this.logLevel = options.loglevel;
        this.alias = options.setalias;
        this.setDefaultDevhubUsername = options.setdefaultdevhubusername;
        this.setDefaultUsername = options.setdefaultusername;
    }
    static getLoginOptions(deviceFlowRequestUrl, clientId) {
        return {
            method: 'POST',
            url: deviceFlowRequestUrl,
            form: {
                response_type: DeviceFlowService.RESPONSE_TYPE,
                client_id: clientId || DeviceFlowService.DEFAULT_CLIENT_ID,
                scope: DeviceFlowService.SCOPE
            },
            json: true
        };
    }
    static getPollingOptions(deviceFlowUrl, loginData, clientId) {
        return {
            method: 'POST',
            url: deviceFlowUrl,
            json: true,
            form: {
                grant_type: DeviceFlowService.GRANT_TYPE,
                code: loginData.device_code,
                client_id: clientId || DeviceFlowService.DEFAULT_CLIENT_ID
            }
        };
    }
    async getDeviceFlowRequestUrl(instanceUrl) {
        this.loginHost = await DeviceFlowService.getInstanceUrl(this.force, instanceUrl);
        return `${this.loginHost}/services/oauth2/token`;
    }
    async getUserProfileUrl(instanceUrl) {
        this.loginHost = await DeviceFlowService.getInstanceUrl(this.force, instanceUrl);
        return `${this.loginHost}/services/oauth2/userinfo`;
    }
    async init() {
        this.logger = await core_2.Logger.child(this.constructor.name);
        this.logger.debug(`this.clientId: ${this.clientId}`);
        this.logger.debug(`this.instanceUrl: ${this.instanceUrl}`);
    }
    get force() {
        if (!this._force) {
            const Force = require('../core/force'); // eslint-disable-line global-require
            this._force = this._force || new Force(new configApi_1.Config());
        }
        return this._force;
    }
    set force(force) {
        this._force = force || this._force;
    }
    static getType(deviceFlowService) {
        let type;
        if (deviceFlowService.setDefaultUsername) {
            type = Org.Defaults.USERNAME;
        }
        else if (deviceFlowService.setDefaultDevhubUsername) {
            type = Org.Defaults.DEVHUB;
        }
        return type;
    }
    /**
     * TODO: This would be a good method to share between web and device auth
     * @param force
     * @param instanceUrl
     */
    static async getInstanceUrl(force, instanceUrl) {
        let promise;
        if (instanceUrl) {
            // Always use the command line instance first;
            return instanceUrl;
        }
        else {
            // Check the env var before local config
            promise = core_3.ConfigAggregator.create().then(aggregator => {
                const instance = aggregator.getInfo('instanceUrl');
                if (instance.isEnvVar()) {
                    return instance.val;
                }
                else {
                    return force.config.getAppConfigIfInWorkspace().sfdcLoginUrl || instance.val || urls.production;
                }
            });
        }
        return promise;
    }
    logHelper(level, append) {
        level = level || 'debug';
        this.logger[level](`clientId: ${this.clientId}`);
        this.logger[level](`instanceUrl: ${this.instanceUrl}`);
        this.logger[level](`loginHost: ${this.loginHost}`);
        if (append) {
            this.logger[level](append);
        }
    }
    async requestDeviceLogin() {
        const deviceFlowRequestUrl = await this.getDeviceFlowRequestUrl(this.instanceUrl);
        const loginOptions = await DeviceFlowService.getLoginOptions(deviceFlowRequestUrl, this.clientId);
        return this.request(loginOptions);
    }
    createPollingFunction(interval, resolve, reject, pollingOptions) {
        return async function repeatedPollingFunction() {
            if (this.pollingCount > DeviceFlowService.POLLING_COUNT_MAX) {
                // stop polling, the user has likely abandoned the command...
                clearTimeout(this.timeout);
                this.logHelper(LogLevel.ERROR, `Polling timed out because max polling was hit: ${this.pollingCount}`);
                reject(core_1.SfdxError.create('salesforce-alm', 'auth', 'device.errors.pollingTimeout'));
            }
            else {
                try {
                    const pollingResponse = await this.getDeviceApproval(pollingOptions);
                    clearTimeout(this.timeout);
                    resolve(pollingResponse);
                }
                catch (err) {
                    if (err.statusCode === 400 && err.error.error === 'authorization_pending') {
                        this.timeout = setTimeout(repeatedPollingFunction.bind(this), interval);
                    }
                    else {
                        clearTimeout(this.timeout);
                        if (err.error && err.error.error) {
                            this.logHelper(LogLevel.ERROR, `Polling error: ${err.error.error}: ${err.error.error_description}`);
                        }
                        else {
                            this.logHelper(LogLevel.ERROR, `Unknown Polling Error: ${err}`);
                        }
                        reject(err);
                    }
                }
                this.pollingCount++;
            }
        }.bind(this);
    }
    startPolling(resolve, reject, loginData, pollingOptions) {
        const interval = loginData.interval * 1000;
        const callback = this.createPollingFunction(interval, resolve, reject, pollingOptions);
        this.timeout = setTimeout(callback, interval);
    }
    async awaitDeviceApproval(loginData) {
        const deviceFlowRequestUrl = await this.getDeviceFlowRequestUrl(this.instanceUrl);
        const pollingOptions = DeviceFlowService.getPollingOptions(deviceFlowRequestUrl, loginData, this.clientId);
        return new Promise((resolve, reject) => {
            this.startPolling(resolve, reject, loginData, pollingOptions);
        });
    }
    async getDeviceApproval(pollingOptions) {
        return this.request(pollingOptions);
    }
    async authorizeAndSave(approval, clientSecret) {
        let orgApi = new Org(this.force, DeviceFlowService.getType(this));
        orgApi.alias = this.alias;
        /**
         * We can't reuse the access_token here because the force library requires a
         * redirect_uri, which we do not have in device flow.  It will exchange the
         * refresh token for a new access token and store that.
         *
         * "ERROR running force:auth:device:login:  redirect_uri must match configuration"
         */
        return this.force.authorizeAndSave({
            instanceUrl: approval.instance_url,
            loginUrl: approval.instance_url,
            refreshToken: approval.refresh_token,
            clientSecret,
            clientId: this.clientId || DeviceFlowService.DEFAULT_CLIENT_ID
        }, orgApi, !!DeviceFlowService.getType(this), (() => {
            throw core_1.SfdxError.create('salesforce-alm', 'auth', 'device.errors.demoModeSupport');
        }).bind(this));
    }
    async doSetAlias(username) {
        if (this.alias && this.alias.length) {
            return Alias.set(this.alias, username);
        }
        else {
            return undefined;
        }
    }
}
exports.DeviceFlowService = DeviceFlowService;
// Public Statics
DeviceFlowService.RESPONSE_TYPE = 'device_code';
DeviceFlowService.GRANT_TYPE = 'device';
DeviceFlowService.SCOPE = 'refresh_token web api';
// Private Statics
DeviceFlowService.DEFAULT_CLIENT_ID = defaultConnectedAppInfo.clientId;
DeviceFlowService.POLLING_COUNT_MAX = 100;

//# sourceMappingURL=deviceFlowService.js.map
