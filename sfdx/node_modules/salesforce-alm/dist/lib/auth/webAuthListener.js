"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Node
const http = require("http");
const net_1 = require("net");
const url_1 = require("url");
const querystring_1 = require("querystring");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const oauthGet = require("./oauthRequest");
// Local
const _DEFAULT_CLIENT_SOCKET_TIMEOUT = 20000;
const messages = core_1.Messages.loadMessages('salesforce-alm', 'webAuthListener');
/**
 * check and get the socket timeout form what was set in process.env.SFDX_HTTP_SOCKET_TIMEOUT
 * @returns {number} - represents the socket timeout in ms
 * @private
 */
const _getSocketTimeout = function () {
    const socketTimeout = kit_1.toNumber(process.env.SFDX_HTTP_SOCKET_TIMEOUT);
    return Number.isInteger(socketTimeout) && socketTimeout > 0 ? socketTimeout : _DEFAULT_CLIENT_SOCKET_TIMEOUT;
};
/**
 * Make sure we can't open a socket on the localhost/host port. It's important because we don't want to send
 * auth tokens to a random strange port listener. We want to make sure we can startup our server first.
 * @param port - default oauth callback port
 * @param host - hostname with localhost default
 * @private
 */
const _checkOsPort = async function (port, host = 'localhost') {
    return new Promise((resolve, reject) => {
        const clientConfig = { port, host };
        const socket = new net_1.Socket();
        socket.setTimeout(_getSocketTimeout(), () => {
            socket.destroy();
        });
        socket.connect(clientConfig, () => {
            socket.destroy();
            // This is just a private rejection error. startOauth rejects with an almError.
            const error = new core_1.SfdxError('Address in use', 'EADDRINUSE');
            error.data = {
                port: clientConfig.port,
                address: clientConfig.host
            };
            reject(error);
        });
        socket.on('error', () => {
            socket.destroy();
            resolve(port);
        });
    });
};
/**
 * sends a response redirect.
 * @param statusCode the statusCode for the response.
 * @param url the url to redirect to.
 * @param response the response to write the redirect to.
 */
function doRedirect(statusCode, url, response) {
    response.setHeader('Content-Type', 'text/plain');
    const body = `${statusCode} - Redirecting to ${url}`;
    response.setHeader('Content-Length', Buffer.byteLength(body));
    response.writeHead(statusCode, { Location: url });
    response.end(body);
}
/**
 * sends a response error.
 * @param statusCode he statusCode for the response.
 * @param message the message for the http body.
 * @param response the response to write the error to.
 */
function sendError(statusCode, message, response) {
    response.statusMessage = message;
    response.statusCode = statusCode;
    response.end();
}
/**
 * close all client sockets and server listener.
 * @param server the server listener to close
 * @param sockets an array of client sockets
 * @param logger
 */
function closeAll(server, sockets, logger) {
    sockets.forEach(socket => {
        socket.end();
        socket.destroy();
    });
    server.getConnections((err, num) => {
        logger.debug(`number of connections open: ${num}`);
    });
    server.close();
}
/**
 * main entry point for service
 */
async function startOauth(listenerConfig) {
    const logger = await core_1.Logger.child('webLogin');
    const port = listenerConfig.orgApi.config.getOauthLocalPort();
    try {
        await _checkOsPort(port);
        logger.debug(`Nothing listening on host: localhost port: ${port} - good!`);
        let _server = listenerConfig.server || http.createServer();
        let sockets = [];
        _server.on('connection', socket => {
            logger.debug(`socket connection initialized from ${socket.remoteAddress}`);
            sockets.push(socket);
        });
        /*This promise is returned to the caller once the server starts listening. When this promise resolves the
         oauth redirect request is then processed by the caller via oauthGet.*/
        const oauthResponse = new Promise((resolve, reject) => {
            _server.on('request', (request, response) => {
                const url = url_1.parse(request.url);
                logger.debug(`processing request for uri: ${url.pathname}`);
                if (request.method === 'GET') {
                    if (url.pathname.startsWith('/OauthRedirect')) {
                        request.query = querystring_1.parse(url.query);
                        response.sendError = (code, message) => {
                            return sendError(code, message, response);
                        };
                        response.redirect = (code, url) => {
                            logger.debug(`sending browser redirect response`);
                            doRedirect(code, url.toString(), response);
                        };
                        logger.debug(`request.query.state: ${request.query.state}`);
                        if (request.query.code && request.query.code.length > 4) {
                            logger.debug(`request.query.code: ${request.query.code.substr(0, 4)} ....`);
                        } // else let an auth failure handle the invalid code
                        oauthGet(listenerConfig.orgApi, listenerConfig.oauthConfig, request, response, listenerConfig.validateState, err => {
                            if (err) {
                                // We don't want to shutdown down the auth process if forged requests are sent.
                                // We gate the requests on a randomly generated expected value being returned from the
                                // oauth core login process.
                                if (err.name !== 'urlStateMismatch') {
                                    reject(err);
                                }
                                else {
                                    logger.warn('urlStateMismatchAttempt detected.');
                                    if (!ts_types_1.get(_server, 'urlStateMismatchAttempt')) {
                                        logger.error(err.message);
                                        kit_1.set(_server, 'urlStateMismatchAttempt', true);
                                    }
                                }
                            }
                            else {
                                resolve();
                            }
                        }, listenerConfig.type, listenerConfig.handleDemoModePrompt);
                    }
                    else {
                        sendError(404, 'Resource not found', response);
                        reject(core_1.SfdxError.create('salesforce-alm', 'webAuth', 'invalidRequestUri', [url.pathname]));
                    }
                }
                else {
                    sendError(405, 'Unsupported http methods', response);
                    reject(core_1.SfdxError.create('salesforce-alm', 'webAuth', 'invalidRequestMethod', [request.method]));
                }
            });
        })
            .then(() => {
            logger.debug('closing server connection');
            closeAll(_server, sockets, logger);
        })
            .catch(err => {
            logger.debug('error reported, closing server connection and re-throwing');
            closeAll(_server, sockets, logger);
            throw err;
        });
        return new Promise(resolve => {
            _server.listen(port, 'localhost');
            _server.once('listening', () => {
                logger.debug(`OAuth web login service listening on port: ${port}`);
                resolve({ oauthResponse });
            });
        });
    }
    catch (err) {
        if (err.name === 'EADDRINUSE') {
            const error = core_1.SfdxError.create('salesforce-alm', 'webAuthListener', 'PortInUse', ['PortInUseAction']);
            error.actions = [messages.getMessage('PortInUseAction', [port])];
            throw error;
        }
        else {
            throw err;
        }
    }
}
exports.startOauth = startOauth;
function getSocketTimeout() {
    return _getSocketTimeout();
}
exports.getSocketTimeout = getSocketTimeout;
exports.DEFAULT_CLIENT_SOCKET_TIMEOUT = _DEFAULT_CLIENT_SOCKET_TIMEOUT;

//# sourceMappingURL=webAuthListener.js.map
