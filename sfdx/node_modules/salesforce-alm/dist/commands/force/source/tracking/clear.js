"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const chalk_1 = require("chalk");
const MaxRevision_1 = require("../../../../lib/source/MaxRevision");
const MetadataRegistry = require("../../../../lib/source/metadataRegistry");
const workspace_1 = require("../../../../lib/source/workspace");
const Org = require('../../../../lib/core/scratchOrgApi');
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('salesforce-alm', 'source_tracking');
// ConfigFile reads the file on init. We don't want to read the file, just delete it.
class OnlyDeletableMaxRevision extends MaxRevision_1.MaxRevision {
    async read(throwOnNotFound, force) {
        return {};
    }
    async write(newContents) {
        return {};
    }
}
// ConfigFile reads the file on init. We don't want to read the file, just delete it.
class OnlyDeletableWorkspace extends workspace_1.Workspace {
    async read(throwOnNotFound, force) {
        return {};
    }
    async write(newContents) {
        return {};
    }
}
class SourceTrackingClearCommand extends command_1.SfdxCommand {
    async run() {
        const clearedFiles = [];
        if (!this.flags.noprompt) {
            const answer = await this.ux.prompt(chalk_1.default.dim(messages.getMessage('promptMessage')));
            if (answer.toLowerCase() !== 'y') {
                // Nothing cleared because it was canceled.
                return { clearedFiles };
            }
        }
        // TODO Remove legacy org from source path status manager and workspace.
        const legacyOrg = new Org();
        const username = this.org.getUsername();
        legacyOrg.setName(username);
        await MetadataRegistry.initializeMetadataTypeInfos(legacyOrg);
        const revision = await OnlyDeletableMaxRevision.create({ username });
        try {
            await revision.unlink();
            clearedFiles.push(revision.getPath());
        }
        catch (e) { }
        // // Reset sourcePathInfos locally
        const workspace = await OnlyDeletableWorkspace.create({
            org: legacyOrg,
            forceIgnore: null,
            isStateless: true
        });
        try {
            await workspace.unlink();
            clearedFiles.push(workspace.getPath());
        }
        catch (e) { }
        this.ux.log('Cleared local tracking files.');
        return { clearedFiles };
    }
}
exports.SourceTrackingClearCommand = SourceTrackingClearCommand;
SourceTrackingClearCommand.description = messages.getMessage('clearDescription');
SourceTrackingClearCommand.longDescription = messages.getMessage('clearLongDescription');
SourceTrackingClearCommand.requiresProject = true;
SourceTrackingClearCommand.requiresUsername = true;
SourceTrackingClearCommand.flagsConfig = {
    noprompt: command_1.flags.boolean({
        char: 'p',
        description: messages.getMessage('nopromptDescription'),
        longDescription: messages.getMessage('nopromptLongDescription'),
        required: false
    })
};

//# sourceMappingURL=clear.js.map
