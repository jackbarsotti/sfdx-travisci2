"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const chalk_1 = require("chalk");
const MaxRevision_1 = require("../../../../lib/source/MaxRevision");
const MetadataRegistry = require("../../../../lib/source/metadataRegistry");
const sourcePathStatusManager_1 = require("../../../../lib/source/sourcePathStatusManager");
const workspace_1 = require("../../../../lib/source/workspace");
const Org = require('../../../../lib/core/scratchOrgApi');
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('salesforce-alm', 'source_tracking');
class SourceTrackingResetCommand extends command_1.SfdxCommand {
    async run() {
        if (!this.flags.noprompt) {
            const answer = await this.ux.prompt(chalk_1.default.dim(messages.getMessage('promptMessage')));
            if (answer.toLowerCase() !== 'y') {
                // Nothing synced because it was canceled.
                return {
                    sourceMembersSynced: 0,
                    localPathsSynced: 0
                };
            }
        }
        // TODO Remove legacy org from source path status manager and workspace.
        const legacyOrg = new Org();
        const username = this.org.getUsername();
        legacyOrg.setName(username);
        await MetadataRegistry.initializeMetadataTypeInfos(legacyOrg);
        // Retrieve and update server members locally
        const revision = await MaxRevision_1.MaxRevision.getInstance({ username });
        const members = await revision.queryAllSourceMembers();
        await revision.updateSourceTracking(members);
        const desiredRevision = this.flags.revision;
        if (ts_types_1.isNumber(desiredRevision)) {
            Object.values(revision.getContents().sourceMembers).forEach(member => {
                if (member.lastRetrievedFromServer > desiredRevision) {
                    member.lastRetrievedFromServer = null; // Say we don't have it
                }
            });
            await revision.write();
        }
        // // Reset sourcePathInfos locally
        const manager = await sourcePathStatusManager_1.SourcePathStatusManager.create({ org: legacyOrg });
        const workspace = manager.workspace;
        await workspace.walkDirectories(workspace.trackedPackages);
        const workspaceElements = workspace.entries();
        workspaceElements.forEach(([_, pathInfo]) => (pathInfo.state = workspace_1.WorkspaceFileState.UNCHANGED));
        await workspace.write();
        this.ux.log(`Reset local tracking files${desiredRevision ? ` to revision ${desiredRevision}` : ''}.`);
        return {
            sourceMembersSynced: members.length,
            localPathsSynced: workspaceElements.length
        };
    }
}
exports.SourceTrackingResetCommand = SourceTrackingResetCommand;
SourceTrackingResetCommand.description = messages.getMessage('resetDescription');
SourceTrackingResetCommand.longDescription = messages.getMessage('resetLongDescription');
SourceTrackingResetCommand.requiresProject = true;
SourceTrackingResetCommand.requiresUsername = true;
SourceTrackingResetCommand.flagsConfig = {
    revision: command_1.flags.integer({
        char: 'r',
        description: messages.getMessage('revisionDescription'),
        longDescription: messages.getMessage('revisionLongDescription'),
        required: false,
        min: 0
    }),
    noprompt: command_1.flags.boolean({
        char: 'p',
        description: messages.getMessage('nopromptDescription'),
        longDescription: messages.getMessage('nopromptLongDescription'),
        required: false
    })
};

//# sourceMappingURL=reset.js.map
