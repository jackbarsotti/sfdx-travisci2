"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("@oclif/errors/lib/errors/cli");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const chalk_1 = require("chalk");
const fs = require("fs");
const _ = require("lodash");
const mkdirp = require("mkdirp");
const path = require("path");
const request = require("request");
const stream_1 = require("stream");
const url_1 = require("url");
const util_1 = require("util");
const error_1 = require("../util/error");
const codeSignApi_1 = require("./codeSignApi");
const mkdirpAsync = util_1.promisify(mkdirp);
/**
 * A special CLIError to print out the canceled instalation without the "Error:" message.
 */
class InstallationCancelError extends cli_1.CLIError {
    constructor(message) {
        super(message || 'The user canceled the plugin installation.');
        this.name = 'InstallationCanceledError';
    }
    render() {
        return ` ${this.bang}   ${chalk_1.default.bold(this.message)}`;
    }
}
exports.WHITELIST_FILENAME = 'unsignedPluginWhiteList.json';
exports.DEFAULT_REGISTRY = 'https://registry.npmjs.org/';
exports.getNpmRegistry = () => {
    return new url_1.URL(process.env.SFDX_NPM_REGISTRY || exports.DEFAULT_REGISTRY);
};
/**
 * simple data structure representing the discovered meta information needed for signing,
 */
class NpmMeta {
}
exports.NpmMeta = NpmMeta;
/**
 * class for verifying a digital signature pack of an npm
 */
class InstallationVerification {
    // tslint:disable-next-line: no-any
    constructor(requestImpl, fsImpl) {
        // why? dependency injection is better than sinon
        this.requestImpl = requestImpl ? requestImpl : request;
        this.fsImpl = fsImpl ? fsImpl : fs;
        this.readFileAsync = util_1.promisify(this.fsImpl.readFile);
        this.unlinkAsync = util_1.promisify(this.fsImpl.unlink);
    }
    /**
     * setter for the cli engine config
     * @param _config cli engine config
     */
    setConfig(_config) {
        if (_config) {
            this.config = _config;
            return this;
        }
        throw new kit_1.NamedError('InvalidParam', 'the cli engine config cannot be null');
    }
    /**
     * setter for the plugin name
     * @param _pluginName the published plugin name
     */
    setPluginNpmName(_pluginName) {
        if (_pluginName) {
            this.pluginNpmName = _pluginName;
            return this;
        }
        throw new kit_1.NamedError('InvalidParam', 'pluginName must be specified.');
    }
    /**
     * validates the digital signature.
     */
    async verify() {
        const logger = await this.getLogger();
        const npmMeta = await this.streamTagGz();
        logger.debug(`verify | Found npmMeta? ${!!npmMeta}`);
        logger.debug(`verify | creating a read stream for path - npmMeta.tarballLocalPath: ${npmMeta.tarballLocalPath}`);
        const info = new codeSignApi_1.CodeVerifierInfo();
        info.dataToVerify = this.fsImpl.createReadStream(npmMeta.tarballLocalPath, { encoding: 'binary' });
        logger.debug(`verify | npmMeta.signatureUrl: ${npmMeta.signatureUrl}`);
        logger.debug(`verify | npmMeta.publicKeyUrl: ${npmMeta.publicKeyUrl}`);
        const _self = this;
        return Promise.all([
            this.getSigningContent(npmMeta.signatureUrl),
            this.getSigningContent(npmMeta.publicKeyUrl)
        ])
            .then(result => {
            info.signatureStream = result[0];
            info.publicKeyStream = result[1];
            return codeSignApi_1.verify(info);
        })
            .then(result => {
            npmMeta.verified = result;
            return _self.unlinkAsync(npmMeta.tarballLocalPath)
                .catch(err => {
                logger.debug(`error occurred deleting cache tgz at path: ${npmMeta.tarballLocalPath}`);
                logger.debug(err);
            }).then(() => npmMeta);
        })
            .catch(e => {
            if (e.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {
                throw new error_1.SignSignedCertError();
            }
            throw e;
        });
    }
    async isWhiteListed() {
        const logger = await this.getLogger();
        const whitelistFilePath = path.join(this.getConfigPath(), exports.WHITELIST_FILENAME);
        logger.debug(`isWhiteListed | whitelistFilePath: ${whitelistFilePath}`);
        try {
            const fileContent = await this.readFileAsync(whitelistFilePath);
            const whitelistArray = JSON.parse(fileContent);
            logger.debug('isWhiteListed | Successfully parsed whitelist.');
            return whitelistArray && whitelistArray.includes(this.pluginNpmName.toString());
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return false;
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Retrieve url content for a host
     * @param url host url.
     */
    getSigningContent(url) {
        return new Promise((resolve, reject) => {
            this.requestImpl(url, (err, response, responseData) => {
                if (err) {
                    return reject(err);
                }
                else {
                    if (response && response.statusCode === 200) {
                        // The verification api expects a readable
                        return resolve(new stream_1.Readable({
                            read() {
                                this.push(responseData);
                                this.push(null);
                            }
                        }));
                    }
                    else {
                        return reject(new kit_1.NamedError('ErrorGettingContent', `A request to url ${url} failed with error code: [${response ? response.statusCode : 'undefined'}]`));
                    }
                }
            });
        });
    }
    /**
     * Downloads the tgz file content and stores it in a cache folder
     */
    async streamTagGz() {
        const logger = await this.getLogger();
        const npmMeta = await this.retrieveNpmMeta();
        const urlObject = new url_1.URL(npmMeta.tarballUrl);
        const urlPathsAsArray = _.split(urlObject.pathname, '/');
        logger.debug(`streamTagGz | urlPathsAsArray: ${urlPathsAsArray}`);
        const fileNameStr = _.last(urlPathsAsArray);
        logger.debug(`streamTagGz | fileNameStr: ${fileNameStr}`);
        // Make sure the cache path exists.
        try {
            await mkdirpAsync(this.getCachePath());
        }
        catch (err) {
            logger.debug(err);
        }
        return new Promise((resolve, reject) => {
            const cacheFilePath = path.join(this.getCachePath(), fileNameStr);
            logger.debug(`streamTagGz | cacheFilePath: ${cacheFilePath}`);
            const writeStream = this.fsImpl.createWriteStream(cacheFilePath, { encoding: 'binary' });
            this.requestImpl(npmMeta.tarballUrl)
                .on('end', () => {
                logger.debug('streamTagGz | Finished writing tgz file');
                npmMeta.tarballLocalPath = cacheFilePath;
                return resolve(npmMeta);
            })
                .on('error', err => {
                logger.debug(err);
                return reject(err);
            })
                .pipe(writeStream);
        });
    }
    // this is generally $HOME/.config/sfdx
    getConfigPath() {
        return this.config.configDir;
    }
    // this is generally $HOME/Library/Caches/sfdx on mac
    getCachePath() {
        return this.config.cacheDir;
    }
    /**
     * Invoke npm to discover a urls for the certificate and digital signature.
     */
    async retrieveNpmMeta() {
        const logger = await this.getLogger();
        return new Promise((resolve, reject) => {
            const npmRegistry = exports.getNpmRegistry();
            logger.debug(`retrieveNpmMeta | npmRegistry: ${npmRegistry}`);
            logger.debug(`retrieveNpmMeta | this.pluginNpmName.name: ${this.pluginNpmName.name}`);
            logger.debug(`retrieveNpmMeta | this.pluginNpmName.scope: ${this.pluginNpmName.scope}`);
            logger.debug(`retrieveNpmMeta | this.pluginNpmName.tag: ${this.pluginNpmName.tag}`);
            if (this.pluginNpmName.scope) {
                npmRegistry.pathname = path.join(npmRegistry.pathname, `@${this.pluginNpmName.scope}%2f${this.pluginNpmName.name}`);
            }
            else {
                npmRegistry.pathname = path.join(npmRegistry.pathname, this.pluginNpmName.name);
            }
            logger.debug(`retrieveNpmMeta | npmRegistry.pathname: ${npmRegistry.pathname}`);
            this.requestImpl(npmRegistry.href, (err, response, body) => {
                if (err) {
                    return reject(err);
                }
                if (response && response.statusCode === 200) {
                    logger.debug('retrieveNpmMeta | Found npm meta information. Parsing.');
                    const responseObj = JSON.parse(body);
                    // Make sure the response has a version attribute
                    if (!responseObj.versions) {
                        return reject(new kit_1.NamedError('InvalidNpmMetadata', `The npm metadata for plugin ${this.pluginNpmName} is missing the versions attribute.`));
                    }
                    // Assume the tag is version tag.
                    // tslint:disable-next-line: no-any
                    let versionObject = _.get(responseObj.versions, this.pluginNpmName.tag);
                    logger.debug(`retrieveNpmMeta | versionObject: ${JSON.stringify(versionObject)}`);
                    // If the assumption was not correct the tag must be a non-versioned dist-tag or not specified.
                    if (!versionObject) {
                        // Assume dist-tag;
                        const distTags = _.get(responseObj, 'dist-tags');
                        logger.debug(`retrieveNpmMeta | distTags: ${distTags}`);
                        if (distTags) {
                            const tagVersionStr = _.get(distTags, this.pluginNpmName.tag);
                            logger.debug(`retrieveNpmMeta | tagVersionStr: ${tagVersionStr}`);
                            // if we got a dist tag hit look up the version object
                            if (tagVersionStr && tagVersionStr.length > 0 && _.includes(tagVersionStr, '.')) {
                                versionObject = _.get(responseObj.versions, tagVersionStr);
                                logger.debug(`retrieveNpmMeta | versionObject: ${JSON.stringify(versionObject)}`);
                            }
                            else {
                                return reject(new kit_1.NamedError('NpmTagNotFound', `The dist tag ${this.pluginNpmName.tag} was not found for plugin: ${this.pluginNpmName}`));
                            }
                        }
                        else {
                            return reject(new kit_1.NamedError('UnexpectedNpmFormat', 'The deployed NPM is missing dist-tags.'));
                        }
                    }
                    if (!(versionObject && versionObject.sfdx)) {
                        return reject(new kit_1.NamedError('NotSigned', 'This plugin is not signed by Salesforce.com, Inc.'));
                    }
                    else {
                        const meta = new NpmMeta();
                        if (!codeSignApi_1.validSalesforceHostname(versionObject.sfdx.publicKeyUrl)) {
                            return reject(new error_1.UnexpectedHost(versionObject.sfdx.publicKeyUrl));
                        }
                        else {
                            logger.debug(`retrieveNpmMeta | versionObject.sfdx.publicKeyUrl: ${versionObject.sfdx.publicKeyUrl}`);
                            meta.publicKeyUrl = versionObject.sfdx.publicKeyUrl;
                        }
                        if (!codeSignApi_1.validSalesforceHostname(versionObject.sfdx.signatureUrl)) {
                            return reject(new error_1.UnexpectedHost(versionObject.sfdx.signatureUrl));
                        }
                        else {
                            logger.debug(`retrieveNpmMeta | versionObject.sfdx.signatureUrl: ${versionObject.sfdx.signatureUrl}`);
                            meta.signatureUrl = versionObject.sfdx.signatureUrl;
                        }
                        meta.tarballUrl = versionObject.dist.tarball;
                        logger.debug(`retrieveNpmMeta | meta.tarballUrl: ${meta.tarballUrl}`);
                        return resolve(meta);
                    }
                }
                else {
                    switch (response.statusCode) {
                        case 403:
                            reject(new kit_1.NamedError('PluginAccessDenied', `Access to the plugin was denied. url: ${npmRegistry.href}`));
                            break;
                        case 404:
                            reject(new kit_1.NamedError('PluginNotFound', `The plugin requested was not found. url: ${npmRegistry.href}.`));
                            break;
                        default:
                            reject(new kit_1.NamedError('UrlRetrieve', `The url request returned ${response.statusCode} - ${npmRegistry.href}`));
                    }
                }
            });
        });
    }
    async getLogger() {
        if (!this.logger) {
            this.logger = await core_1.Logger.child('InstallationVerification');
        }
        return this.logger;
    }
}
exports.InstallationVerification = InstallationVerification;
class VerificationConfig {
    get verifier() {
        return this._verifier;
    }
    set verifier(value) {
        this._verifier = value;
    }
    get log() {
        return this._log;
    }
    set log(value) {
        this._log = value;
    }
    get prompt() {
        return this._prompt;
    }
    set prompt(value) {
        this._prompt = value;
    }
}
exports.VerificationConfig = VerificationConfig;
async function doPrompt(vconfig) {
    const _continue = await vconfig.prompt(chalk_1.default.dim('This plugin is not digitally signed and its authenticity cannot be verified. Continue installation y/n?'));
    switch (_.toLower(_continue)) {
        case 'y':
            return;
        default:
            throw new InstallationCancelError();
    }
}
exports.doPrompt = doPrompt;
async function doInstallationCodeSigningVerification(config, { plugin, tag }, verificationConfig) {
    try {
        const meta = await verificationConfig.verifier.verify();
        if (!meta.verified) {
            // noinspection ExceptionCaughtLocallyJS
            throw new kit_1.NamedError('FailedDigitalSignatureVerification', 'A digital signature is specified for this plugin but it didn\'t verify against the certificate.');
        }
        verificationConfig.log(`Successfully validated digital signature for ${plugin}.`);
    }
    catch (err) {
        if (err.name === 'NotSigned') {
            if (await verificationConfig.verifier.isWhiteListed()) {
                verificationConfig.log(`The plugin [${plugin}] is not digitally signed but it is white-listed.`);
                return;
            }
            else {
                return await doPrompt(verificationConfig);
            }
        }
        else if (err.name === 'PluginNotFound' || err.name === 'PluginAccessDenied') {
            throw new InstallationCancelError(err.message);
        }
        throw err;
    }
}
exports.doInstallationCodeSigningVerification = doInstallationCodeSigningVerification;
//# sourceMappingURL=installationVerification.js.map