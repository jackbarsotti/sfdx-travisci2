"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const command_1 = require("@salesforce/command");
const kit_1 = require("@salesforce/kit");
const installationVerification_1 = require("../../../codeSigning/installationVerification");
const NpmName_1 = require("../../../util/NpmName");
// sfdx plugins:trust:verify --npm @salesforce/jj@0.0.1 --registry http://tnoonan-wsm2.internal.salesforce.com:4874/
// noinspection JSUnusedGlobalSymbols
class Verify extends command_1.SfdxCommand {
    async run() {
        this.ux.log('Checking for digital signature.');
        const npmName = NpmName_1.NpmName.parse(this.flags.npm);
        this.logger.debug(`running verify command for npm: ${npmName}`);
        const vConfig = new installationVerification_1.VerificationConfig();
        const configContext = {
            cacheDir: _.get(this.config, 'configDir'),
            configDir: _.get(this.config, 'cacheDir'),
            dataDir: _.get(this.config, 'dataDir')
        };
        this.logger.debug(`cacheDir: ${configContext.cacheDir}`);
        this.logger.debug(`configDir: ${configContext.configDir}`);
        this.logger.debug(`dataDir: ${configContext.dataDir}`);
        vConfig.verifier = this.getVerifier(npmName, configContext);
        vConfig.log = this.ux.log.bind(this.ux);
        if (this.flags.registry) {
            process.env.SFDX_NPM_REGISTRY = this.flags.registry;
        }
        try {
            const meta = await vConfig.verifier.verify();
            this.logger.debug(`meta.verified: ${meta.verified}`);
            if (!meta.verified) {
                // noinspection ExceptionCaughtLocallyJS
                throw new kit_1.NamedError('FailedDigitalSignatureVerification', 'A digital signature is specified for this plugin but it didn\'t verify against the certificate.');
            }
            const message = `Successfully validated digital signature for ${npmName.name}.`;
            if (!this.flags.json) {
                vConfig.log(message);
            }
            else {
                return { message, verified: true };
            }
        }
        catch (err) {
            this.logger.debug(`err reported: ${JSON.stringify(err, null, 4)}`);
            const response = {
                verified: false,
                message: err.message
            };
            if (err.name === 'NotSigned') {
                let message = err.message;
                if (await vConfig.verifier.isWhiteListed()) {
                    message = `The plugin [${npmName.name}] is not digitally signed but it is white-listed.`;
                    vConfig.log(message);
                    response.message = message;
                }
                else {
                    message = 'The plugin is not digitally signed.';
                    vConfig.log(message);
                    response.message = message;
                }
                return response;
            }
            throw err;
        }
    }
    getVerifier(npmName, config) {
        return new installationVerification_1.InstallationVerification()
            .setPluginNpmName(npmName)
            .setConfig(config);
    }
}
Verify.description = 'For an npm validate the associated digital signature if it exits.';
Verify.examples = [
    '$ sfdx plugins:trust:verifySignature --npm @scope/npmName --registry http://my.repo.org:4874',
    '$ sfdx plugins:trust:verifySignature --npm @scope/npmName'
];
Verify.flagsConfig = {
    npm: command_1.flags.string({
        char: 'n',
        required: true,
        description: 'Specify the npm name. This can include a tag/version'
    }),
    registry: command_1.flags.string({
        char: 'r',
        required: false,
        description: 'The registry name. the behavior is the same as npm.'
    })
};
// Comment this out if your command does not require an org username
Verify.requiresUsername = false;
// Comment this out if your command does not support a hub org username
Verify.supportsDevhubUsername = false;
// Set this to true if your command requires a project workspace; 'requiresProject' is false by default
Verify.requiresProject = false;
exports.Verify = Verify;
//# sourceMappingURL=verify.js.map