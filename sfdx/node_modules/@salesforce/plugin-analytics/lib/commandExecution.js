"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const parser_1 = require("@oclif/parser");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const path_1 = require("path");
const debuger_1 = require("./debuger");
const analyticsInit_1 = require("./hooks/analyticsInit");
class CommandExecution extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.specifiedFlags = [];
        this.specifiedFlagFullNames = [];
        this.start = Date.now();
        this.command = options.command;
        this.argv = options.argv;
        this.config = options.config;
        this.upTimeAtCmdStart = process.uptime() * 1000;
    }
    /**
     * Determines whether the SFDX project is using GIT for version control or some other VCS.
     * Returns a token indicating the VCS for usage stats, or an empty string if the command
     * was executed outside of an SFDX project.
     */
    static async resolveVCSInfo() {
        let possibleVcsPath;
        try {
            possibleVcsPath = await core_1.SfdxProject.resolveProjectPath();
        }
        catch (err) {
            debuger_1.debug('Not in a sfdx project, using current working directory');
            possibleVcsPath = process.cwd();
        }
        const gitPath = path_1.join(possibleVcsPath, '.git');
        try {
            await core_1.fs.access(gitPath, core_1.fs.constants.R_OK);
            return 'git';
        }
        catch (err) {
            return 'other';
        }
    }
    toJson() {
        return {
            eventName: 'COMMAND_EXECUTION',
            // System information
            platform: this.config.platform,
            shell: this.config.shell,
            arch: this.config.arch,
            vcs: this.vcs,
            nodeEnv: process.env.NODE_ENV,
            processUptime: process.uptime() * 1000,
            // CLI information
            version: this.config.version,
            channel: this.config.channel,
            origin: this.config.userAgent,
            plugin: this.command.plugin && this.command.plugin.name,
            plugin_version: this.command.plugin && this.command.plugin.version,
            command: this.command.id,
            // As the user specified, including short names
            specifiedFlags: this.specifiedFlags.join(' '),
            // Flags the user specified, only the full names
            specifiedFlagFullNames: this.specifiedFlagFullNames.join(' '),
            sfdxEnv: process.env.SFDX_ENV,
            s3HostOverride: process.env.SFDX_S3_HOST,
            npmRegistryOverride: process.env.SFDX_NPM_REGISTRY,
            tool: process.env.SFDX_TOOL,
            interceptorMode: process.env.INTERCEPTOR_MODE,
            // Execution information
            date: new Date().toUTCString(),
            // Don't log status or timestamp as a number, otherwise vscode will think it is a metric
            status: ts_types_1.isNumber(this.status) ? this.status.toString() : undefined,
            timestamp: String(Date.now()),
            runtime: Date.now() - this.start,
            upTimeAtCmdStart: this.upTimeAtCmdStart,
            oclifLoadTime: analyticsInit_1.InitData.upTimeAtInit,
            commandLoadTime: this.upTimeAtCmdStart - analyticsInit_1.InitData.upTimeAtInit,
            // Salesforce Information
            // Set the usernames so the uploader can resolve it to orgIds.
            // Since resolving org ids can make API calls, we want to do that in the
            // uploader process so we don't slow down the CLI.
            devHubUsername: this.devHubOrgUsername,
            orgUsername: this.orgUsername
        };
    }
    async init() {
        const argv = this.argv;
        const flagDefinitions = this.command.flags || {};
        // We can't get varargs on type Class, so we need to cast to any to parse flags properly
        // tslint:disable-next-line: no-any
        const anyCmd = this.command;
        const commandDef = { flags: flagDefinitions, args: this.command.args, strict: !anyCmd.varargs };
        // tslint:disable-next-line: no-any
        let flags = {};
        try {
            flags = parser_1.parse(argv, commandDef).flags;
        }
        catch (error) {
            debuger_1.debug('Error parsing flags');
        }
        this.orgUsername = flags.targetusername;
        this.devHubOrgUsername = flags.targetdevhubusername;
        this.determineSpecifiedFlags(argv, flags, flagDefinitions);
        this.vcs = await CommandExecution.resolveVCSInfo();
    }
    // tslint:disable-next-line: no-any
    determineSpecifiedFlags(argv, flags, flagDefinitions) {
        // Help won't be in the parsed flags
        const shortHelp = argv.find(arg => /^-h$/.test(arg));
        const fullHelp = argv.find(arg => /^--help$/.test(arg));
        if (shortHelp || fullHelp) {
            if (shortHelp) {
                this.specifiedFlags.push('h');
            }
            else {
                this.specifiedFlags.push('help');
            }
            this.specifiedFlagFullNames.push('help');
            // All other flags don't matter if help is specified, so end here.
        }
        else {
            Object.keys(flags).forEach(flagName => {
                const shortCode = flagDefinitions[flagName] && flagDefinitions[flagName].char;
                // Oclif will include the flag if there is a default, but we only want to add it if the
                // user specified it, so confirm in the argv list.
                if (shortCode && argv.find(arg => new RegExp(`^-${shortCode}(=.*)?$`).test(arg))) {
                    this.specifiedFlags.push(shortCode);
                    this.specifiedFlagFullNames.push(flagName);
                }
                else if (argv.find(arg => new RegExp(`^--${flagName}(=.*)?$`).test(arg))) {
                    this.specifiedFlags.push(flagName);
                    this.specifiedFlagFullNames.push(flagName);
                }
            });
        }
    }
}
exports.CommandExecution = CommandExecution;
//# sourceMappingURL=commandExecution.js.map