"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const child_process_1 = require("child_process");
const crypto_1 = require("crypto");
const systemFs = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const debuger_1 = require("./debuger");
const CLI_ID_FILE_NAME = 'CLIID.txt';
const USAGE_ACKNOWLEDGEMENT_FILE_NAME = 'acknowledgedUsageCollection.json';
class Analytics extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.firstRun = false;
        if (options.cacheDir && !Analytics.cacheDir) {
            Analytics.cacheDir = options.cacheDir;
        }
        // We want to run off of a specific analytics file, so override.
        if (options.analyticsFilePath) {
            Analytics.analyticsTmpFile = options.analyticsFilePath;
        }
    }
    /**
     * Tell the user they acknowledge data collection.
     */
    static async acknowledgeDataCollection() {
        // Only check once per process, regardless of how often this is instantiated.
        if (Analytics.acknowledged) {
            return;
        }
        if (!Analytics.cacheDir) {
            debuger_1.debug('Unable to check acknowledgment path because Analytics.cacheDir is not set yet');
            return;
        }
        const acknowledgementFilePath = path_1.join(Analytics.cacheDir, USAGE_ACKNOWLEDGEMENT_FILE_NAME);
        try {
            await core_1.fs.access(acknowledgementFilePath, core_1.fs.constants.R_OK);
            debuger_1.debug('Usage acknowledgement file already exists');
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                if (!kit_1.env.getBoolean('SFDX_TELEMETRY_DISABLE_ACKNOWLEDGEMENT', false)) {
                    console.warn('You acknowledge and agree that the CLI tool may collect usage information, ' +
                        'user environment, and crash reports for the purposes of providing services or functions that are relevant ' +
                        'to use of the CLI tool and product improvements.', os_1.EOL);
                }
                Analytics.acknowledged = true;
                await core_1.fs.mkdirp(Analytics.cacheDir);
                await core_1.fs.writeJson(acknowledgementFilePath, { acknowledged: true });
                debuger_1.debug('Wrote usage acknowledgement file', acknowledgementFilePath);
            }
            else {
                debuger_1.debug('Could not access', acknowledgementFilePath, 'DUE TO:', err.code, err.message);
            }
        }
    }
    static guessCISystem() {
        const keys = Object.keys(process.env);
        if (keys.find(key => key.startsWith('CIRCLE'))) {
            return 'circleci';
        }
        if (keys.find(key => key.startsWith('TRAVIS'))) {
            return 'travisci';
        }
        if (keys.find(key => key.startsWith('GITHUB_ACTION'))) {
            return 'github_actions';
        }
        if (keys.find(key => key.startsWith('AGENT_NAME')) || keys.find(key => key.startsWith('BUILD_BUILDNUMBER'))) {
            return 'azure_pipelines';
        }
        if (keys.find(key => key.startsWith('TEAMCITY'))) {
            return 'teamcity';
        }
        if (keys.find(key => key.startsWith('GITLAB'))) {
            return 'gitlab';
        }
        if (keys.find(key => key.startsWith('NEVERCODE'))) {
            return 'nevercode';
        }
        if (keys.find(key => key.startsWith('WERCKER'))) {
            return 'wercker';
        }
        if (keys.find(key => key.startsWith('BUILDKITE'))) {
            return 'buildkite';
        }
        if (keys.find(key => key.startsWith('SEMAPHORE'))) {
            return 'semaphore';
        }
        if (keys.find(key => key.startsWith('BITRISE'))) {
            return 'bitrise';
        }
        if (keys.find(key => key.startsWith('BUDDY'))) {
            return 'buddy';
        }
        if (keys.find(key => key.startsWith('APPVEYOR'))) {
            return 'appveyor';
        }
        if (keys.find(key => key.startsWith('JENKINS'))) {
            return 'jenkins';
        }
        if (keys.find(key => key === 'CI' || key === 'CONTINUOUS_INTEGRATION')) {
            return 'unknown';
        }
    }
    static generateRandomId() {
        return crypto_1.randomBytes(20).toString('hex');
    }
    getAnalyticsLogFilePath() {
        return Analytics.analyticsTmpFile;
    }
    getCLIId() {
        if (this.cliId)
            return this.cliId;
        const cliIdPath = path_1.join(Analytics.cacheDir, CLI_ID_FILE_NAME);
        try {
            this.cliId = systemFs.readFileSync(cliIdPath, 'utf8');
        }
        catch (err) {
            debuger_1.debug('Unique CLI ID not found, generating and writing new ID to ', cliIdPath);
            this.cliId = Analytics.generateRandomId();
            systemFs.writeFileSync(cliIdPath, this.cliId, 'utf8');
            // If there is not a unique ID for this CLI, consider it a first run.
            this.firstRun = true;
        }
        return this.cliId;
    }
    /**
     * Record data to the analytics file. Only valid properties will be recorded to the file, which
     * are strings, numbers, and booleans. All booleans get logged to App Insights as string representations.
     */
    record(data) {
        // Only store valid telemetry attributes to the log file.
        const dataToRecord = Object.keys(data).reduce((map, key) => {
            const value = data[key];
            const isException = data.type === Analytics.EXCEPTION && key === 'error';
            const validType = ts_types_1.isString(value) || ts_types_1.isBoolean(value) || ts_types_1.isNumber(value);
            if (isException || validType) {
                map[key] = value;
            }
            return map;
        }, {});
        if (!dataToRecord.type) {
            dataToRecord.type = Analytics.EVENT;
        }
        if (!dataToRecord.eventName) {
            // This would mean a consumer forgot to set this.
            // Still log it as unknown so we can try to fix it.
            dataToRecord.eventName = 'UNKNOWN';
            // Don't break this into a utility because the stack HAS to start from this method.
            const stack = new Error().stack || '';
            const locations = stack.split(os_1.EOL).filter(line => /\s*at /.test(line));
            if (locations.length >= 2) {
                // The first location is this file, the second is the calling file.
                // Replace HOME for GDPR.
                dataToRecord.requestorLocation = locations[1].replace(process.env.HOME || '', '');
            }
            debuger_1.debug('Missing event name!');
        }
        // Unique to this CLI installation
        dataToRecord.cliId = this.getCLIId();
        dataToRecord.ci = Analytics.guessCISystem();
        try {
            systemFs.writeSync(this.fileDescriptor, JSON.stringify(dataToRecord) + os_1.EOL);
        }
        catch (error) {
            debuger_1.debug(`Error saving analytics line to file: ${error.message}`);
        }
    }
    recordError(error, data) {
        data.type = Analytics.EXCEPTION;
        // Also have on custom attributes since app insights might parse differently
        data.errorName = error.name;
        data.errorMessage = error.message;
        data.error = Object.assign({
            name: error.name,
            message: error.message,
            stack: error.stack
        }, error);
        this.record(data);
    }
    async clear() {
        debuger_1.debug('Deleting the log file', this.getAnalyticsLogFilePath());
        await core_1.fs.unlink(this.getAnalyticsLogFilePath());
    }
    async read() {
        try {
            debuger_1.debug(`Reading ${this.getAnalyticsLogFilePath()}`);
            const data = await core_1.fs.readFile(this.getAnalyticsLogFilePath(), 'utf8');
            const events = data
                .split(os_1.EOL)
                .filter(line => !!line)
                .map(line => JSON.parse(line));
            return events;
        }
        catch (err) {
            debuger_1.debug(`Error reading: ${err.message}`);
            // If anything goes wrong, it just means a couple of lost telemetry events.
            return [];
        }
    }
    upload() {
        // Completely disconnect from this process so it doesn't wait for telemetry to upload
        const processPath = path_1.join(__dirname, '..', 'processes', 'upload');
        const telemetryDebug = kit_1.env.getBoolean('SFDX_TELEMETRY_DEBUG', false);
        const nodePath = process.argv[0];
        // Don't spawn if we are in telemetry debug. This allows us to run the process manually with --inspect-brk.
        if (!telemetryDebug) {
            debuger_1.debug(`Spawning "${nodePath} ${processPath} ${Analytics.cacheDir} ${this.getAnalyticsLogFilePath()}"`);
            child_process_1.spawn(nodePath, [processPath, Analytics.cacheDir, this.getAnalyticsLogFilePath()], {
                detached: true,
                stdio: 'ignore'
            }).unref();
        }
        else {
            debuger_1.debug(`DEBUG MODE. Run the uploader manually with the following command:${os_1.EOL}${processPath} ${Analytics.cacheDir} ${this.getAnalyticsLogFilePath()}`);
        }
    }
    async init() {
        // If we are going to record analytics, make sure the user is aware.
        await Analytics.acknowledgeDataCollection();
        // Make sure the tmp dir is created.
        try {
            await core_1.fs.access(Analytics.tmpDir, core_1.fs.constants.W_OK);
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                debuger_1.debug('Analytics temp dir does not exist, creating...');
                await core_1.fs.mkdirp(Analytics.tmpDir);
            }
        }
        // Create a file descriptor to be used
        this.fileDescriptor = systemFs.openSync(this.getAnalyticsLogFilePath(), 'a');
        debuger_1.debug(`Using analytics logging file ${this.getAnalyticsLogFilePath()}`);
    }
}
exports.default = Analytics;
/**
 * The name of event telemetry type.
 */
Analytics.EVENT = 'EVENT';
/**
 * The name of exception telemetry type.
 */
Analytics.EXCEPTION = 'EXCEPTION';
/**
 * The temporary directory where analytic log files are stored.
 */
Analytics.tmpDir = kit_1.env.getString('SFDX_TELEMETRY_PATH', path_1.join(os_1.tmpdir(), 'sfdx-analytics'));
Analytics.analyticsTmpFile = path_1.join(Analytics.tmpDir, `analytics-${Analytics.generateRandomId()}.log`);
Analytics.acknowledged = false;
//# sourceMappingURL=analytics.js.map