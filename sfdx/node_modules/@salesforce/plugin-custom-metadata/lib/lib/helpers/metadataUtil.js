"use strict";
/*
 * Copyright (c) 2018-2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataUtil = void 0;
const ts_types_1 = require("@salesforce/ts-types");
class MetadataUtil {
    constructor(connection) {
        this.conn = connection;
    }
    /**
     * Returns a describe object from the API name you specify
     *
     * @param  objName API name of the object
     * @returns Promise - JSON representation of the describe object
     */
    async describeObj(objName) {
        const result = await this.conn.metadata.read('CustomObject', objName, (err, meta) => {
            if (err) {
                const errorResponse = { errorCode: '', errorMessage: '' };
                errorResponse.errorCode = err.name;
                errorResponse.errorMessage = err.message;
                return errorResponse;
            }
            return meta;
        });
        return ts_types_1.toAnyJson(result);
    }
    /**
     * Returns an array of object records from a SOQL query
     *
     * @param  soqlStr String representation of the SOQL query
     * @returns Promise - Array of records in JSON format
     */
    async queryObject(soqlStr) {
        const result = await this.conn.query(soqlStr, {}, (err, meta) => {
            if (err) {
                const errorResponse = { errorCode: '', errorMessage: '' };
                errorResponse.errorCode = err.name;
                errorResponse.errorMessage = err.message;
                return errorResponse;
            }
            return meta;
        });
        return ts_types_1.toAnyJson(result);
    }
    /**
     * Returns an array of object records
     *
     * @param  describeResult object describe result
     * @returns Promise - Promise - Array of records in JSON format
     */
    async queryRecords(describeResult) {
        const query = await this._getSoqlQuery(describeResult['fields'], describeResult['fullName']);
        const queryResult = await this.queryObject(query);
        return ts_types_1.toAnyJson(queryResult);
    }
    /**
     * Returns describe object for the field API name from the Object API name you specify
     *
     * @param  objDescribe  describe object JSON
     * @param  fieldName API name of the field to query
     * @returns Promise - Promise - record in JSON format
     */
    describeField(objDescribe, fieldName) {
        const fieldsDescribe = objDescribe['fields'];
        let fieldsDescribeResult;
        fieldsDescribe.map(field => {
            if (field.fullName === fieldName) {
                fieldsDescribeResult = field;
            }
        });
        return fieldsDescribeResult;
    }
    /**
     * Returns describe object for all fields from the object  API name you specify
     *
     * @param  objDescribe object describe JSON
     * @returns Promise - Promise - record in JSON format
     */
    describeObjFields(objDescribe) {
        const fieldsDescribe = objDescribe['fields'];
        return fieldsDescribe;
    }
    /**
     * Returns true if the object name you specify is a list type custom setting
     *
     * @param  objName API name of the object to query
     * @returns boolean
     */
    validCustomSettingType(objDescribe) {
        if (objDescribe['customSettingsType'] === 'List' && objDescribe['visibility'] === 'Public') {
            return true;
        }
        return false;
    }
    cleanQueryResponse(sObjecRecord, objectDescribe) {
        const record = {};
        Object.keys(sObjecRecord).forEach(fieldName => {
            if (fieldName !== 'attributes' && fieldName !== 'Name') {
                const fieldDescribe = this.describeField(objectDescribe, fieldName);
                const fieldType = fieldDescribe['type'];
                const fieldValue = JSON.stringify(sObjecRecord[fieldName]);
                if (fieldType === 'Location') {
                    if (fieldValue.includes('latitude') || fieldValue.includes('longitude')) {
                        record['Lat_' + fieldName] = fieldValue.slice(fieldValue.indexOf(':') + 1, fieldValue.indexOf(','));
                        record['Long_' + fieldName] = fieldValue.slice(fieldValue.lastIndexOf(':') + 1, fieldValue.indexOf('}'));
                    }
                    else {
                        record['Lat_' + fieldName] = '';
                        record['Long_' + fieldName] = '';
                    }
                }
                else {
                    record[fieldName] = sObjecRecord[fieldName];
                }
            }
        });
        return record;
    }
    _getSoqlQuery(arr, objName) {
        const fieldNames = arr.map(field => {
            return field.fullName;
        }).join(',');
        // Added Name hardcoded as Name field is not retreived as part of object describe.
        return `SELECT Name, ${fieldNames} FROM ${objName}`;
    }
}
exports.MetadataUtil = MetadataUtil;
//# sourceMappingURL=metadataUtil.js.map