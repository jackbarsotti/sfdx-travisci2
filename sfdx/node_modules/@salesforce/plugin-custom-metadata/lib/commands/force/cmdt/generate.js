"use strict";
/*
 * Copyright (c) 2018-2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@salesforce/command");
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const util_1 = require("util");
const createUtil_1 = require("../../../lib/helpers/createUtil");
const fileWriter_1 = require("../../../lib/helpers/fileWriter");
const metadataUtil_1 = require("../../../lib/helpers/metadataUtil");
const validationUtil_1 = require("../../../lib/helpers/validationUtil");
const templates_1 = require("../../../lib/templates/templates");
// Initialize Messages with the current plugin directory
command_1.core.Messages.importMessagesDirectory(__dirname);
// Load the specific messages for this file. Messages from @salesforce/command, @salesforce/core,
// or any library that is using the messages framework can also be loaded this way.
const messages = command_1.core.Messages.loadMessages('@salesforce/plugin-custom-metadata', 'generate');
let Generate = /** @class */ (() => {
    class Generate extends command_1.SfdxCommand {
        async run() {
            // this.org is guaranteed because requiresUsername=true, as opposed to supportsUsername
            const conn = this.org.getConnection();
            // to validate different flags provided by the user
            const validator = new validationUtil_1.ValidationUtil();
            const objname = this.flags.sobjectname;
            const cmdttype = this.flags.devname;
            const sourceuser = this.flags.targetusername;
            const ignoreFields = this.flags.ignoreunsupported;
            let username;
            let sourceOrgConn;
            let describeObj;
            // check whether username or alias is provided as targetusername
            if (!util_1.isNullOrUndefined(sourceuser)) {
                if (sourceuser.substr(sourceuser.length - 4) !== '.com') {
                    username = await core_1.Aliases.fetch(sourceuser); // if alias is provided get the corresponding username
                    if (username === undefined) {
                        throw core_1.SfdxError.create('@salesforce/plugin-custom-metadata', 'generate', 'sourceusernameError', [sourceuser]);
                    }
                }
                else {
                    username = sourceuser;
                }
            }
            if (!util_1.isNullOrUndefined(username)) {
                try {
                    // connect to source org if source user name provided
                    sourceOrgConn = await command_1.core.Connection.create({
                        authInfo: await command_1.core.AuthInfo.create({ username })
                    });
                }
                catch (err) {
                    const errMsg = messages.getMessage('sourceuserAuthenticationError', [sourceuser, err.message]);
                    throw new core_1.SfdxError(errMsg, 'sourceuserAuthenticationError');
                }
            }
            if (!validator.validateAPIName(objname)) {
                throw core_1.SfdxError.create('@salesforce/plugin-custom-metadata', 'generate', 'sobjectnameFlagError', [objname]);
            }
            let devName;
            if (!validator.validateMetadataTypeName(cmdttype)) {
                throw core_1.SfdxError.create('@salesforce/plugin-custom-metadata', 'generate', 'typenameFlagError', [cmdttype]);
            }
            if (cmdttype.endsWith('__mdt') || cmdttype.endsWith('__MDT')) {
                devName = cmdttype.substring(0, cmdttype.indexOf('__mdt'));
            }
            else {
                devName = cmdttype;
            }
            let metadataUtil;
            // get defined only if there is source username provided
            if (!sourceOrgConn) {
                metadataUtil = new metadataUtil_1.MetadataUtil(conn);
            }
            else {
                metadataUtil = new metadataUtil_1.MetadataUtil(sourceOrgConn);
            }
            // use default target org connection to get object describe if no source is provided.
            describeObj = await metadataUtil.describeObj(objname);
            // throw error if the object doesnot exist(empty json as response from the describe call.)
            if (kit_1.isEmpty(describeObj)) {
                const errMsg = messages.getMessage('sobjectnameNoResultError', [objname]);
                throw new core_1.SfdxError(errMsg, 'sobjectnameNoResultError');
            }
            // check for custom setting
            if (describeObj['customSettingsType'] !== undefined) {
                // if custom setting check for type and visbility
                if (!metadataUtil.validCustomSettingType(describeObj)) {
                    const errMsg = messages.getMessage('customSettingTypeError', [objname]);
                    throw new core_1.SfdxError(errMsg, 'customSettingTypeError');
                }
            }
            const visibility = this.flags.visibility || 'Public';
            const label = this.flags.label || devName;
            const pluralLabel = this.flags.plurallabel || label;
            const outputDir = this.flags.typeoutputdir || 'force-app/main/default/objects/';
            const recordsOutputDir = this.flags.recordsoutputdir || 'force-app/main/default/customMetadata';
            try {
                this.ux.startSpinner('custom metadata generation in progress');
                // create custom metadata type
                const templates = new templates_1.Templates();
                const objectXML = templates.createObjectXML({ label, pluralLabel }, visibility);
                const fileWriter = new fileWriter_1.FileWriter();
                await fileWriter.writeTypeFile(command_1.core.fs, outputDir, devName, objectXML);
                // get all the field details before creating feild metadata
                const describeAllFields = metadataUtil.describeObjFields(describeObj);
                let sObjectRecords;
                // query records from source
                sObjectRecords = await metadataUtil.queryRecords(describeObj);
                if (sObjectRecords.errorCode && sObjectRecords.errorCode !== null) {
                    const errMsg = messages.getMessage('queryError', [objname, ts_types_1.asString(sObjectRecords.errorMsg)]);
                    throw new core_1.SfdxError(errMsg, 'queryError');
                }
                // check for Geo Location fields before hand and create two different fields for longitude and latitude.
                const fields = ts_types_1.ensureJsonArray(describeAllFields);
                fields.map(field => {
                    if (field['type'] === 'Location') {
                        const lat = {
                            fullName: 'Lat_' + field['fullName'],
                            label: 'Lat ' + field['label'],
                            required: field['required'],
                            trackHistory: field['trackHistory'],
                            trackTrending: field['trackTrending'],
                            type: 'Text',
                            length: '40'
                        };
                        fields.push(lat);
                        const long = {
                            fullName: 'Long_' + field['fullName'],
                            label: 'Long_' + field['label'],
                            required: field['required'],
                            trackHistory: field['trackHistory'],
                            trackTrending: field['trackTrending'],
                            type: 'Text',
                            length: '40'
                        };
                        fields.push(long);
                    }
                });
                // create custom metdata fields
                for (const field of fields) {
                    // added type check here to skip the creation of geo location field  and un supported fields as we are adding it as lat and long field above.
                    if ((templates.canConvert(field['type']) || !ignoreFields) && field['type'] !== 'Location') {
                        const recordname = field['fullName'];
                        const fieldXML = templates.createFieldXML(field, !ignoreFields);
                        const targetDir = `${outputDir}${devName}__mdt`;
                        await fileWriter.writeFieldFile(command_1.core.fs, targetDir, recordname, fieldXML);
                    }
                }
                const createUtil = new createUtil_1.CreateUtil();
                // if customMetadata folder does not exist, create it
                await command_1.core.fs.mkdirp(recordsOutputDir);
                const security = (visibility !== 'Public');
                const typename = devName;
                const fieldDirPath = `${fileWriter.createDir(outputDir)}${typename}__mdt/fields`;
                const fileNames = await command_1.core.fs.readdir(fieldDirPath);
                const fileData = await createUtil.getFileData(fieldDirPath, fileNames);
                for (const rec of sObjectRecords.records) {
                    const record = metadataUtil.cleanQueryResponse(rec, describeObj);
                    const lblName = rec['Name'];
                    let recordName = rec['Name'];
                    if (!validator.validateMetadataRecordName(rec['Name'])) {
                        recordName = recordName.replace(/ +/g, '_');
                    }
                    await createUtil.createRecord({
                        typename,
                        recordname: recordName,
                        label: lblName,
                        inputdir: outputDir,
                        outputdir: recordsOutputDir,
                        protected: security,
                        varargs: record,
                        fileData,
                        ignorefields: ignoreFields
                    });
                }
                this.ux.stopSpinner('custom metadata type and records creation in completed');
                this.ux.log(`Congrats! Created a ${devName} custom metadata type with ${sObjectRecords.records.length} records!`);
            }
            catch (e) {
                await command_1.core.fs.remove(`${outputDir}${devName}__mdt`);
                const fileNames = await command_1.core.fs.readdir(recordsOutputDir);
                for (const file of fileNames) {
                    if (file.startsWith(devName)) {
                        try {
                            await command_1.core.fs.unlink(`${recordsOutputDir}/${file}`);
                        }
                        catch (e) {
                            this.ux.log(e.message);
                        }
                    }
                }
                this.ux.stopSpinner('generate command failed to run');
                const errMsg = messages.getMessage('generateError', [e.message]);
                throw new core_1.SfdxError(errMsg, 'generateError');
            }
            return { outputDir, recordsOutputDir };
        }
    }
    Generate.description = messages.getMessage('commandDescription');
    Generate.longDescription = messages.getMessage('commandLongDescription');
    Generate.examples = [
        messages.getMessage('exampleCaption1'),
        '    $ sfdx force:cmdt:generate --devname MyCMDT --sobjectname MySourceObject__c',
        messages.getMessage('exampleCaption2'),
        '    $ sfdx force:cmdt:generate --devname MyCMDT --sobjectname MySourceObject__c  --ignoreunsupported --targetusername \'' + messages.getMessage('targetusernameFlagExample') + '\'',
        messages.getMessage('exampleCaption3'),
        '    $ sfdx force:cmdt:generate --devname MyCMDT --sobjectname SourceCustomObject__c  --visibility Protected',
        messages.getMessage('exampleCaption4'),
        '    $ sfdx force:cmdt:generate --devname MyCMDT --label "' + messages.getMessage('labelFlagExample') + '" ' +
            '--plurallabel "' + messages.getMessage('plurallabelFlagExample') + '" --sobjectname SourceCustomSetting__c  --visibility Protected',
        messages.getMessage('exampleCaption5'),
        '    $ sfdx force:cmdt:generate --devname MyCMDT --sobjectname SourceCustomSetting__c --typeoutputdir \'' + messages.getMessage('typeoutputdirFlagExample') + '\'',
        messages.getMessage('exampleCaption6'),
        '    $ sfdx force:cmdt:generate --devname MyCMDT --sobjectname SourceCustomSetting__c --recordsoutputdir \'' + messages.getMessage('recordsoutputdirFlagExample') + '\''
    ];
    Generate.args = [{ name: 'file' }];
    Generate.flagsConfig = {
        // flag with a value (-n, --name=VALUE)
        devname: command_1.flags.string({
            char: 'n',
            required: true,
            description: messages.getMessage('devnameFlagDescription'),
            longDescription: messages.getMessage('devnameFlagLongDescription')
        }),
        label: command_1.flags.string({
            char: 'l',
            description: messages.getMessage('labelFlagDescription'),
            longDescription: messages.getMessage('labelFlagLongDescription')
        }),
        plurallabel: command_1.flags.string({
            char: 'p',
            description: messages.getMessage('plurallabelFlagDescription'),
            longDescription: messages.getMessage('plurallabelFlagLongDescription')
        }),
        visibility: command_1.flags.enum({
            char: 'v',
            description: messages.getMessage('visibilityFlagDescription'),
            longDescription: messages.getMessage('visibilityFlagLongDescription'),
            options: ['PackageProtected', 'Protected', 'Public'],
            default: 'Public'
        }),
        sobjectname: command_1.flags.string({
            char: 's',
            required: true,
            description: messages.getMessage('sobjectnameFlagDescription'),
            longDescription: messages.getMessage('sobjectnameFlagLongDescription')
        }),
        ignoreunsupported: command_1.flags.boolean({
            char: 'i',
            description: messages.getMessage('ignoreUnsupportedFlagDescription'),
            longDescription: messages.getMessage('ignoreUnsupportedFlagLongDescription')
        }),
        typeoutputdir: command_1.flags.directory({
            char: 'd',
            description: messages.getMessage('typeoutputdirFlagDescription'),
            longDescription: messages.getMessage('typeoutputdirFlagLongDescription'),
            default: 'force-app/main/default/objects/'
        }),
        recordsoutputdir: command_1.flags.directory({
            char: 'r',
            description: messages.getMessage('recordsoutputdirFlagDescription'),
            longDescription: messages.getMessage('recordsoutputdirFlagLongDescription'),
            default: 'force-app/main/default/customMetadata/'
        })
    };
    // Comment this out if your command does not require an org username
    Generate.requiresUsername = true;
    // Set this to true if your command requires a project workspace; 'requiresProject' is false by default
    Generate.requiresProject = true;
    return Generate;
})();
exports.default = Generate;
//# sourceMappingURL=generate.js.map