"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileWriter = void 0;
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const crypto = require("crypto");
const fs = require("fs");
const signalExit = require("signal-exit");
class FileWriter {
    constructor() {
        /*
         * Queue of files to write. May be a new file or replace an existing one.
         */
        this.writeQueue = [];
        /*
         * Queue of files to append data to.
         */
        this.appendQueue = [];
        /*
         * An object mapping filenames to their temporary copy. We use the temp copy to
         * save a copy of the original file in case of any unexpected early termination of the run. If an error does
         * occur, all previous files that were modified are replaced with the
         * original content saved to the temp file.
         */
        this.tmpFilelist = {};
        /*
         * Save references to new files created so that if we need to revert back to our original state we know to remove these.
         */
        this.newFiles = [];
    }
    queueWrite(filepath, content, options) {
        this.writeQueue.push({
            filepath,
            content,
            options
        });
    }
    queueAppend(filepath, toAppend, options) {
        this.appendQueue.push({
            filepath,
            toAppend,
            options
        });
    }
    writeFiles() {
        const cleanup = this.revertChanges();
        const removeExitHandler = signalExit(cleanup);
        try {
            this.appendQueue.forEach(item => {
                const tmpFilename = item.filepath + '.' + this.getHash(item.filepath);
                if (!fs.existsSync(item.filepath)) {
                    throw new Error('Attempting to append to file that does not exist: ' + item.filepath);
                }
                fs.copyFileSync(item.filepath, tmpFilename);
                this.tmpFilelist[item.filepath] = tmpFilename;
                fs.appendFileSync(item.filepath, item.toAppend, item.options);
            });
            this.writeQueue.forEach(item => {
                const tmpFilename = item.filepath + '.' + this.getHash(item.filepath);
                if (fs.existsSync(item.filepath)) {
                    fs.copyFileSync(item.filepath, tmpFilename);
                    this.tmpFilelist[item.filepath] = tmpFilename;
                }
                else {
                    this.newFiles.push(item.filepath);
                }
                fs.writeFileSync(item.filepath, item.content, item.options);
            });
            // things worked fine so remove handler and only remove temp files
            removeExitHandler();
            this.removeTempFiles();
        }
        catch (e) {
            // TODO(tbliss): how to get access to the same logger that the commands have?
            console.log('Error writing files. Attempting to revert back to original state.');
            console.log(e);
            removeExitHandler();
            cleanup();
        }
    }
    revertChanges() {
        return () => {
            // replace original files with temp backups
            Object.keys(this.tmpFilelist).forEach(item => {
                fs.copyFileSync(this.tmpFilelist[item], item);
            });
            this.newFiles.forEach(file => {
                fs.unlinkSync(file);
            });
            this.removeTempFiles();
        };
    }
    removeTempFiles() {
        Object.keys(this.tmpFilelist).forEach(item => {
            fs.unlinkSync(this.tmpFilelist[item]);
        });
    }
    getHash(filename) {
        return crypto
            .createHash('md5')
            .update(filename, 'utf8')
            .update(String(process.pid), 'utf8')
            .digest('hex');
    }
}
exports.FileWriter = FileWriter;
//# sourceMappingURL=fileWriter.js.map